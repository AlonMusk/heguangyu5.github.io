<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../bootstrap-3.3.5/css/bootstrap.min.css">
<link rel="stylesheet" href="../prism.css">
</head>
<body>
<div class="container">

<h1 class="page-header">nginx 1.14.0</h1>

<h3>configure</h3>
<pre><code class="language-c">
./configure --help

# add all --without options except --without-http
# add --with-stream
./configure --prefix=/home/hgy/nginx-1.14.0 \
            --without-select_module \
            --without-poll_module \
            --without-http_charset_module \
            --without-http_gzip_module \
            --without-http_ssi_module \
            --without-http_userid_module \
            --without-http_access_module \
            --without-http_auth_basic_module \
            --without-http_mirror_module \
            --without-http_autoindex_module \
            --without-http_geo_module \
            --without-http_map_module \
            --without-http_split_clients_module \
            --without-http_referer_module \
            --without-http_rewrite_module \
            --without-http_proxy_module \
            --without-http_fastcgi_module \
            --without-http_uwsgi_module \
            --without-http_scgi_module \
            --without-http_grpc_module \
            --without-http_memcached_module \
            --without-http_limit_conn_module \
            --without-http_limit_req_module \
            --without-http_empty_gif_module \
            --without-http_browser_module \
            --without-http_upstream_hash_module \
            --without-http_upstream_ip_hash_module \
            --without-http_upstream_least_conn_module \
            --without-http_upstream_keepalive_module \
            --without-http_upstream_zone_module \
            --without-http-cache \
            --without-mail_pop3_module \
            --without-mail_imap_module \
            --without-mail_smtp_module \
            --without-stream_limit_conn_module \
            --without-stream_access_module \
            --without-stream_geo_module \
            --without-stream_map_module \
            --without-stream_split_clients_module \
            --without-stream_return_module \
            --without-stream_upstream_hash_module \
            --without-stream_upstream_least_conn_module \
            --without-stream_upstream_zone_module \
            --without-pcre \
            --with-stream

/*
configure 生成了根目录的 Makefile 和 objs 目录
根目录的Makefile很简单，指向了 objs/Makefile
objs/Makefile 定义了 target objs/nginx

objs/nginx: objs/src/xxx/xxx.o
    gcc -o objs/nginx objs/src/xxx/xxx.o -ldl -lpthread -Wl,-E
-Wl,option Pass option as an option to the linker.

objs/src/xxx/xxx.o: src/xxx/xxx.c
    gcc -o objs/src/xxx/xxx.o src/xxx/xxx.c

configure 生成的 objs 目录如下：
.
├── autoconf.err
├── Makefile
├── ngx_auto_config.h
├── ngx_auto_headers.h
├── ngx_modules.c
└── src
    ├── core
    ├── event
    │   └── modules
    ├── http
    │   ├── modules
    │   │   └── perl
    │   └── v2
    ├── mail
    ├── misc
    ├── os
    │   ├── unix
    │   └── win32
    └── stream
*/

# ngx_modules.c

extern ngx_module_t  ngx_core_module;
extern ngx_module_t  ngx_errlog_module;
extern ngx_module_t  ngx_conf_module;
extern ngx_module_t  ngx_events_module;
extern ngx_module_t  ngx_event_core_module;
extern ngx_module_t  ngx_epoll_module;
extern ngx_module_t  ngx_http_module;
extern ngx_module_t  ngx_http_core_module;
extern ngx_module_t  ngx_http_log_module;
extern ngx_module_t  ngx_http_upstream_module;
extern ngx_module_t  ngx_http_static_module;
extern ngx_module_t  ngx_http_index_module;
extern ngx_module_t  ngx_http_try_files_module;
extern ngx_module_t  ngx_http_write_filter_module;
extern ngx_module_t  ngx_http_header_filter_module;
extern ngx_module_t  ngx_http_chunked_filter_module;
extern ngx_module_t  ngx_http_range_header_filter_module;
extern ngx_module_t  ngx_http_headers_filter_module;
extern ngx_module_t  ngx_http_copy_filter_module;
extern ngx_module_t  ngx_http_range_body_filter_module;
extern ngx_module_t  ngx_http_not_modified_filter_module;
extern ngx_module_t  ngx_stream_module;
extern ngx_module_t  ngx_stream_core_module;
extern ngx_module_t  ngx_stream_log_module;
extern ngx_module_t  ngx_stream_proxy_module;
extern ngx_module_t  ngx_stream_upstream_module;
extern ngx_module_t  ngx_stream_write_filter_module;

ngx_module_t *ngx_modules[] = {
    &ngx_core_module,
    &ngx_errlog_module,
    &ngx_conf_module,
    &ngx_events_module,
    &ngx_event_core_module,
    &ngx_epoll_module,
    &ngx_http_module,
    &ngx_http_core_module,
    &ngx_http_log_module,
    &ngx_http_upstream_module,
    &ngx_http_static_module,
    &ngx_http_index_module,
    &ngx_http_try_files_module,
    &ngx_http_write_filter_module,
    &ngx_http_header_filter_module,
    &ngx_http_chunked_filter_module,
    &ngx_http_range_header_filter_module,
    &ngx_http_headers_filter_module,
    &ngx_http_copy_filter_module,
    &ngx_http_range_body_filter_module,
    &ngx_http_not_modified_filter_module,
    &ngx_stream_module,
    &ngx_stream_core_module,
    &ngx_stream_log_module,
    &ngx_stream_proxy_module,
    &ngx_stream_upstream_module,
    &ngx_stream_write_filter_module,
    NULL
};

char *ngx_module_names[] = {
    "ngx_core_module",
    "ngx_errlog_module",
    "ngx_conf_module",
    "ngx_events_module",
    "ngx_event_core_module",
    "ngx_epoll_module",
    "ngx_http_module",
    "ngx_http_core_module",
    "ngx_http_log_module",
    "ngx_http_upstream_module",
    "ngx_http_static_module",
    "ngx_http_index_module",
    "ngx_http_try_files_module",
    "ngx_http_write_filter_module",
    "ngx_http_header_filter_module",
    "ngx_http_chunked_filter_module",
    "ngx_http_range_header_filter_module",
    "ngx_http_headers_filter_module",
    "ngx_http_copy_filter_module",
    "ngx_http_range_body_filter_module",
    "ngx_http_not_modified_filter_module",
    "ngx_stream_module",
    "ngx_stream_core_module",
    "ngx_stream_log_module",
    "ngx_stream_proxy_module",
    "ngx_stream_upstream_module",
    "ngx_stream_write_filter_module",
    NULL
};

typedef struct ngx_module_s ngx_module_t;

struct ngx_module_s {
    ngx_uint_t ctx_index;
    ngx_uint_t index;

    char *name;

    ngx_uint_t spare0;
    ngx_uint_t spare1;

    ngx_uint_t version;
    const char *signature;

    void *ctx;
    ngx_command_t *commands;
    ngx_uint_t type;

    ngx_int_t (*init_master)(ngx_log_t *log);

    ngx_int_t (*init_module)(ngx_cycle_t *cycle);

    ngx_int_t (*init_process)(ngx_cycle_t *cycle);
    ngx_int_t (*init_thread)(ngx_cycle_t *cycle);
    void (*exit_thread)(ngx_cycle_t *cycle);
    void (*exit_process)(ngx_cycle_t *cycle);

    void (*exit_master)(ngx_cycle_t *cycle);

    uintptr_t spare_hook0;
    uintptr_t spare_hook1;
    uintptr_t spare_hook2;
    uintptr_t spare_hook3;
    uintptr_t spare_hook4;
    uintptr_t spare_hook5;
    uintptr_t spare_hook6;
    uintptr_t spare_hook7;
};
</code></pre>

<h3>ngx_pool_t 内存管理</h3>
<pre><code class="language-c">
ngx_pool_t *ngx_create_pool(size_t size, ngx_log_t *log);
    // 分配一块大小为size的内存,开头一段保存ngx_pool_t信息,后边是可分配空间
    struct ngx_pool_s {
        struct nginx_pool_data_t {
            u_char      *last;  // 内存分配到哪个地方了,下次分配时从这个位置开始
            u_char      *end;   // 内存块结束的位置,pool不记录大小,通过end-pool得到大小
            ngx_pool_t  *next;  // 当前可分配内存不够时,会再分配一块内存,pool中所有的内存块通过next形成一个单链表
            ngx_uint_t  failed; // 如果当前内存块超过4次都分配失败,更改pool.current的指向下一个内存块,
                                // 这样不用每次都从链表的开头遍历
        } d;
        size_t max; // 内存块减去开头的ngx_pool_t后,最大可用空间,分配内存时,
                    // 如果小于这个大小,调用ngx_palloc_small,从链表的内存块中找可用内存
                    // 如果大于这个大小,调用ngx_palloc_large,直接malloc,
                    // 并ngx_palloc_small一个ngx_pool_large_t,将malloc返回的指针记录在large->alloc里
                    // 多个large通过next形成另一个单链表
        ngx_pool_t *current;
        ngx_chain_t *chain;
        ngx_pool_large_t *large; {
            ngx_pool_large_t *next;
            void             *alloc;
        }
        ngx_pool_cleanup_t *cleanup; {
            ngx_pool_cleanup_pt handler;
            void *data;
            ngx_pool_cleanup_t *next;
        }
        ngx_log_t *log; // 内存分配出错,方便记录出错信息
    }

void *ngx_palloc(ngx_pool_t *pool, size_t size);
    // 如果size <= pool->max, ngx_palloc_small, 否则ngx_palloc_large
void *ngx_pnalloc(ngx_pool_t *pool, size_t size);
    // 同ngx_palloc,只不过不需要内存对齐
ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment);
    // 直接分配内存,也当作large加入到large链表里
ngx_pcalloc(ngx_pool_t *pool, size_t size);
    // 先调用ngx_palloc分配内存,然后将分配的内存清0
ngx_pool_cleanup_t *ngx_pool_cleanup_add(ngx_pool_t *p, size_t size);
    // 将分配的内存封装在ngx_pool_cleanup_t里,这样可以添加一个handler/callback,
    // 在需要时通过遍历cleanup链表对分配的内存执行动作
ngx_pfree(ngx_pool_t *pool, void *p);
    // free large内存块
ngx_reset_pool(ngx_pool_t *pool);
    // free large内存块,将small内存块全部标记为可用
ngx_destroy_pool(ngx_pool_t *pool);
    // 1. run cleanup handler
    // 2. free large
    // 3. free small
</code></pre>

<h3>ngx_array_t 动态数组</h3>
<pre><code class="language-c">
ngx_array_t *ngx_array_create(ngx_pool_t *p, ngx_uint_t n, size_t size);
    // 创建一个新数组,n个元素,每个元素大小为size
    struct ngx_array_t {
        void        *elts;  // ngx_palloc(pool, n * size), 真正的数组元素
        ngx_uint_t  nelts;  // 当前使用量
        size_t      size;   // 数组元素大小
        ngx_uint_t  nalloc; // 可用量/已分配量
        ngx_pool_t  *pool;
    }

void *ngx_array_push(ngx_array_t *a);
void *ngx_array_push_n(ngx_array_t *a, ngx_uint_t n);
    // 返回数组元素开始指针
void ngx_array_destroy(ngx_array_t *a);
    // 如果数组在pool的末尾,标记为可用内存,否则,不做处理
</code></pre>

<h3>main()</h3>
<pre><code class="language-c">// http://localhost/lxr/source/src/core/nginx.c?v=nginx-1.14.0#0195
ngx_strerror_init();
    // 初始化ngx_sys_errlist, NGX_SYS_NERR = 135
    // 注释里说的很清楚为什么要有ngx_sys_errlist
ngx_get_options();
    // -p => ngx_prefix
    // -c => ngx_conf_file
    // -g => ngx_conf_params
    // -s => ngx_signal, ngx_process = NGX_PROCESS_SIGNALLER

ngx_time_init();

// 这里涉及一个C语言的用法,如果没有define过NGX_PCRE,if就是false
// 前边我们configure时有参数--without-pcre,所以就没有define NGX_PCRE,这里就直接跳过了
#if (NGX_PCRE)
    ngx_regex_init();
#endif

ngx_pid = getpid();
ngx_parent = getppid();

ngx_log_init(ngx_prefix);
    // @see objs/ngx_auto_config.h
    // NGX_ERROR_LOG_PATH "logs/error.log"
    // NGX_PREFIX  "/home/hgy/nginx-1.14.0/"
    ngx_log.log_level = NGX_LOG_NOTICE;
    ngx_log.file      = &ngx_log_file = {
        .fd = open(
            NGX_PREFIX . NGX_ERROR_LOG_PATH, // /home/hgy/nginx-1.14.0/logs/error.log
            NGX_FILE_APPEND | NGX_FILE_CREATE_OR_OPEN,
            NGX_FILE_DEFAULT_ACCESS
        )
    };
    // 如果open失败，ngx_log.file.fd = STDERR_FILENO

ngx_memzero(&init_cycle, sizeof(ngx_cycle_t));
init_cycle.log = &ngx_log;
ngx_cycle = &init_cycle;
init_cycle.pool = ngx_create_pool(1024, &ngx_log);

ngx_save_argv(cycle, argc, argv);
    ngx_os_argv = (char **)argv;
    ngx_argc    = argc;
    ngx_argv    = ngx_alloc((argc + 1) * sizeof(char *)); // copy argv to ngx_argv
    ngx_argv[i] = NULL;
    ngx_os_environ = environ;

ngx_process_options();
    // @see objs/ngx_auto_config.h
    // NGX_CONF_PREFIX  "conf/"
    // NGX_CONF_PATH  "conf/nginx.conf"
    init_cycle.conf_prefix = NGX_CONF_PREFIX = "conf/";
    init_cycle.prefix      = NGX_PREFIX      = "/home/hgy/nginx-1.14.0/";
    init_cycle.conf_file   = NGX_CONF_PATH   = "conf/nginx.conf";
    ngx_conf_full_name(cycle, &cycle->conf_file, 0);
        ngx_get_full_name(cycle->pool, cycle->prefix, cycle->conf_file);
            // 最终 cycle->conf_file = "/home/hgy/nginx-1.14.0/conf/nginx.conf"

ngx_os_init();
    ngx_os_specific_init(); // 调用uname()取得ostype,osrelease, ngx_os_io = ngx_linux_io;
    ngx_init_setproctitle(); // 把environ复制一份,上边已经把argv复制了一份,现在可以放心的修改os的argv,env了
    ngx_ncpu = sysconf(_SC_NPROCESSORS_ONLN);
    ngx_cpuinfo(); // 调用cpuid取得cacheline_size
    ngx_max_sockets = rlim_cur; // getrlimit(RLIMIT_NOFILE, &rlmt)
    // NGX_HAVE_ACCEPT4  1 @see ngx_auto_config.h
    ngx_inherited_nonblocking = 1;

ngx_crc32_table_init();
ngx_add_inherited_sockets();

ngx_preinit_modules();
    // 给每个module设上index和name,同时也得到了module的数量 ngx_modules_n
    // 和 ngx_max_module = ngx_modules_n + NGX_MAX_DYNAMIC_MODULES(128);

cycle = ngx_init_cycle(&init_cycle);
    /*
        新创建一个cycle
        把init_cycle的log,conf_prefix,prefix,conf_file,conf_param都给copy过来
        初始化   paths
                config_dump
                config_dump_rbtree
                open_files
                shared_memory
                listening
                reusable_connections_queue
                conf_ctx
                hostname
                modules
    /*

    // 遍历cycle->modules中module.type=NGX_CORE_MODULE的module,如果create_conf方法,调用之,
    // 返回结果保存到cycle->conf_ctx[module->index]里.
    typedef struct {
        ngx_str_t             name;
        void               *(*create_conf)(ngx_cycle_t *cycle);
        char               *(*init_conf)(ngx_cycle_t *cycle, void *conf);
    } ngx_core_module_t;
    /*
        哪些是NGX_CORE_MODULE?
        ngx_module_t *ngx_modules[] = {
            *CORE*   &ngx_core_module,
            *CORE*   &ngx_errlog_module,
             CONF    &ngx_conf_module,
            *CORE*   &ngx_events_module,
            EVENT    &ngx_event_core_module,
            EVENT    &ngx_epoll_module,
            *CORE*   &ngx_http_module,
            HTTP     &ngx_http_core_module,
            HTTP     &ngx_http_log_module,
            HTTP     &ngx_http_upstream_module,
            HTTP     &ngx_http_static_module,
            HTTP     &ngx_http_index_module,
            HTTP     &ngx_http_try_files_module,
            HTTP     &ngx_http_write_filter_module,
            HTTP     &ngx_http_header_filter_module,
            HTTP     &ngx_http_chunked_filter_module,
            HTTP     &ngx_http_range_header_filter_module,
            HTTP     &ngx_http_headers_filter_module,
            HTTP     &ngx_http_copy_filter_module,
            HTTP     &ngx_http_range_body_filter_module,
            HTTP     &ngx_http_not_modified_filter_module,
            *CORE*   &ngx_stream_module,
            STREAM   &ngx_stream_core_module,
            STREAM   &ngx_stream_log_module,
            STREAM   &ngx_stream_proxy_module,
            STREAM   &ngx_stream_upstream_module,
            STREAM   &ngx_stream_write_filter_module,
            NULL
        };
        CORE MODULE             create_conf                     init_conf
        ngx_core_module         ngx_core_module_create_conf     ngx_core_module_init_conf
        ngx_errlog_module       NULL                            NULL
        ngx_events_module       NULL                            ngx_event_init_conf
        ngx_http_module         NULL                            NULL
        ngx_stream_module       NULL                            NULL
    */
    ngx_core_module_create_conf(cycle)
        ngx_core_conf_t *ccf = ngx_pcalloc();
        ccf->daemon = NGX_CONF_UNSET;
        ccf->master = NGX_CONF_UNSET;
        ccf->worker_processes = NGX_CONF_UNSET;
        // ...
        return ccf;

    /*
        初始化conf
        ngx_conf_param(&conf); => 处理参数-g,最终调用ngx_conf_parse(cf, NULL)
        ngx_conf_parse(&conf, &cycle->conf_file)
    */
    ngx_conf_parse(&conf, &cycle->conf_file)
        /*
            worker_processes  1;
            events {
                worker_connections  1024;
            }
            http {
                include       mime.types;
                default_type  application/octet-stream;

                sendfile on;
                keepalive_timeout  65;

                server {
                    listen       80;
                    server_name  localhost;

                    location / {
                        root   html;
                        index  index.html index.htm;
                    }

                    error_page   500 502 503 504  /50x.html;
                    location = /50x.html {
                        root   html;
                    }
                }
            }
        */
        rc = ngx_conf_read_token(cf);
        // 从 nginx.conf 文件中读取一个token
        ngx_conf_handler(cf, rc);
        // 遍历 modules 的 commands, 找到 token 对应的 cmd
            cmd->set(cf, cmd, conf)
            // 第一个参数cf(conf),是当前整个conf上下文
            // 第三个参数conf,是和module自身相关的.
            //      比如 worker_processes cmd, 它的type是NGX_DIRECT_CONF,
            //      此时conf就是ngx_core_module在init_conf时创建的那个conf.

            typedef struct ngx_command_s {
                ngx_str_t   name;
                ngx_uint_t  type;
                char        *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
                ngx_uint_t  conf;
                ngx_uint_t  offset;
                void        *post;
            } ngx_command_t;

            // worker_processes command
            {
                ngx_string("worker_processes"),
                NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
                ngx_set_worker_processes
                0,
                0,
                NULL
            }

            typedef struct {
                ngx_flag_t                daemon;
                ngx_flag_t                master;

                ngx_msec_t                timer_resolution;

                ngx_int_t                 worker_processes;
                ngx_int_t                 debug_points;

                ngx_int_t                 rlimit_nofile;
                off_t                     rlimit_core;

                int                       priority;

                ngx_uint_t                cpu_affinity_auto;
                ngx_uint_t                cpu_affinity_n;
                ngx_cpuset_t             *cpu_affinity;

                char                     *username;
                ngx_uid_t                 user;
                ngx_gid_t                 group;

                ngx_str_t                 working_directory;
                ngx_str_t                 lock_file;

                ngx_str_t                 pid;
                ngx_str_t                 oldpid;

                ngx_array_t               env;
                char                    **environment;
            } ngx_core_conf_t;

            // events command
            {
                ngx_string("events"),
                NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
                ngx_events_block,
                0,
                0,
                NULL
            }
            // events cmd的type是NGX_MAIN_CONF,在调用ngx_event_block时第三个参数传的是
            // conf_ctx[module->index]的地址,而ngx_events_module没有create_conf,
            // 所以当前这个地址里保存的指针是NULL
            ngx_events_block()
                ngx_event_max_module = ngx_count_modules(cf->cycle, NGX_EVENT_MODULE);
                // count的过程其实就是给每个EVENT MODULE设定ctx_index的过程
                /*
                    然后分配一个ngx_event_max_module个元素的指针数组*ctx,
                    遍历EVENT MODULE,调用module的create_conf,返回结果保存到(*ctx)[module->ctx_index].
                    最后将ctx的地址保存到conf_ctx[module->index]里

                    NGX_EVENT_MODULE对我们来说就2个:

                    struct ngx_event_module_t {
                        ngx_str_t *name;
                        void *(*create_conf)(ngx_cycle_t *cycle);
                        char *(*init_conf)(ngx_cycle_t *cycle, void *conf);

                        ngx_event_actions_t actions;
                    }

                    EVENT MODULE            create_conf                 init_conf
                    ngx_event_core_module   ngx_event_core_create_conf  ngx_event_core_init_conf
                    ngx_epoll_module        ngx_epoll_create_conf       ngx_epoll_init_conf

                    数据结构是这样的:
                    cycle->conf_ctx
                    | 0                 | -> ngx_core_conf_t
                    | 1                 |
                    | 2                 |
                    | 3                 | -> ngx_event_modules_ctx_ptr -> ngx_event_modules_ctx
                    | .                 |                                 | 0 | -> ngx_event_conf_t
                    | ngx_max_module -1 |                                 | 1 | -> ngx_epoll_conf_t
                */

                // 接下来将cf另存一份,更改cf的ctx,module_type,cmd_type,继续ngx_conf_parse events block
                // worker_connections command
                {
                    ngx_string("worker_connections"),
                    NGX_EVENT_CONF|NGX_CONF_TAKE1,
                    ngx_event_connections,
                    0,
                    0,
                    NULL
                }
                struct ngx_event_conf_t {
                    ngx_uint_t    connections;
                    ngx_uint_t    use;
                    ngx_flag_t    multi_accept;
                    ngx_flag_t    accept_mutex;
                    ngx_msec_t    accept_mutex_delay;
                    u_char       *name;
                };
                // ngx_epoll_module 有两个配置项,我们没有用到
                struct ngx_epoll_conf_t {
                    ngx_uint_t events;
                    ugx_uint_t aio_requests;
                };

                // 然后恢复cf,遍历EVENT MODULE,如果有init_conf方法(这两个module都有),
                // 将前边create_conf返回的conf传入init_conf(cf->cycle, (*ctx)[module->ctx_index])
                ngx_event_core_init_conf();
                    // 确定使用哪个event module,对我们来说,就是epoll
                    ngx_event_conf_t {
                        connections = 1024;
                        use = 1; // ngx_epoll_module->ctx_index
                        name = "epoll";
                        multi_accept = 0;
                        accept_mutex = 0;
                        accept_mutex_delay = 500;
                    }
                ngx_epoll_init_conf();
                    ngx_epoll_conf_t {
                        events = 512;
                        aio_requests = 32;
                    }

            // http command
            {
                ngx_string("http"),
                NGX_MAIN_CONF|NGX_CONF_BLOCK|NGX_CONF_NOARGS,
                ngx_http_block,
                0,
                0,
                NULL
            }
            // http cmd的type也是NGX_MAIN_CONF,在调用ngx_http_block时第三个参数传的是
            // conf_ctx[module->index]的地址,而ngx_http_module没有create_conf,
            // 所以当前这个地址里保存的指针是NULL
            ngx_http_block()
                ngx_http_conf_ctx_t *ctx = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t));
                *conf = ctx;

                struct ngx_http_conf_ctx_t {
                    void        **main_conf;
                    void        **srv_conf;
                    void        **loc_conf;
                };

                ngx_http_max_module = ngx_count_modules(cf->cycle, NGX_HTTP_MODULE);
                // 遍历的同时将http module也设定了module.ctx_index
                ctx->mail_conf = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
                ctx->srv_conf  = ...
                ctx->loc_conf  = ...
                // 遍历http module,调用module对应的create_main_conf, create_srv_conf, create_loc_conf
                // 更改ctx,再次遍历,调用module->preconfiguration()
                // 更改module_type,cmd_type,ngx_conf_parse http block
                // 遍历http module,调用init_main_conf, ngx_http_merge_servers
                // init locations, init static locations
                // init phases, init headers in hash
                // 遍历http module,调用module->postconfiguration()
                // init vars
                // init phase handlers
                // optimize servers

    // 从ngx_conf_parse返回后,遍历CORE MODULE,如果module有init_conf方法,调用之.
    // 对我们来说,有两个init_conf方法
    ngx_core_module_init_conf()
        daemon = 1;
        master = 1;
        // ...
    ngx_event_init_conf()
        // 主要是确保有events配置

    // 后边还有很长很长的代码
    ngx_init_modules(); // 调用module的init_module()方法


ngx_os_status();
    // 如果error.log配置的是notice的话,这里会打印出 nginx version, built by, ostype, osrelease, rlimit_nofile

ngx_cycle = cycle;

ccf = (ngx_core_conf_t *)ngx_get_conf(cycle->conf_ctx, ngx_core_module);
if (ccf->master && ngx_process == NGX_PROCESS_SINGLE) {
    ngx_process = NGX_PROCESS_MASTER;
}

ngx_init_signals(); // 绑定signal handler -> ngx_signal_handler
ngx_daemon(); // daemonize, 并重定向STDIN,STDOUT到/dev/null
ngx_daemonized = 1;

ngx_create_pidfile();
</code></pre>

<h3>ngx_master_process_cycle(cycle);</h3>
<pre><code class="language-c">// 首先,block住几个signal
ngx_setproctitle(); // nginx: master process ./sbin/nginx

typedef struct {
    ngx_pid_t pid;
    int status;
    ngx_socket_t channel[2];

    ngx_spawn_proc_pt proc;
    void *data;
    char *name;

    unsigned respawn:1;
    unsigned just_spawn:1;
    unsigned detached:1;
    unsigned exiting:1;
    unsigned exited:1;
} ngx_process_t;
ngx_process_t ngx_processes[NGX_MAX_PROCESSES=1024];

ngx_start_worker_processes(cycle, ccf->worker_processes = 1, NGX_PROCESS_RESPAWN);
    ngx_spawn_process(cycle, ngx_worker_process_cycle, NULL, "worker_process", type = NGX_PROCESS_RESPAWN);
    // ngx_last_process记录着worker process的数量,最大值是1024
    // 给process创建一个socketpair, ngx_process_t.channel[2]
    //      channel[0]: FIONBIO FIOASYNC, F_SETOWN=ngx_pid, F_SETFD=FD_CLOEXEC
    //      channel[1]: FIONBIO         ,                   F_SETFD=FD_CLOEXEC
    // socketpair好了之后,fork()
    //      fork出来的子进程更新ngx_pid为其自己的pid,然后调用ngx_worker_process_cycle(cycle, data = NULL)不再返回
    //      父进程继续执行,在ngx_processes里记录这个进程的pid,name等信息,并设respawn=1

    ngx_pass_open_channel(cycle, channel = {command=NGX_CMD_OPEN_CHANNEL,pid,slot,fd});
    // 将channel_t写到socketpair[0]里,还不知道有什么用

ngx_start_cache_manager_processes(cycle, 0); // 先略过

// 然后在一个死循环中等待signal
sigsuspend(&set = EMPTY);
// man sigsuspend()可知, sigsuspend()返回后,sig mask又恢复了
// 也就是说,你可以给nginx发信号,但nginx收到第一个后,就不再收第二个了,直到它处理完第一个信号后,又sigsuspend()时才可以再处理其它信号
</code></pre>

<h3>ngx_worker_process_cycle(cycle, data = NULL)</h3>
<pre><code class="language-c">ngx_process = NGX_PROCESS_WORKER;
ngx_worker_process_init(cycle, 1);
    ngx_set_environment(); // nginx.conf里可以添加env变量,在这里将这此变量加到environ里
    setrlimit();
    setgid(); // 如果以root权限启动
    setuid(); // 如果以root权限启动
    chdir();
    sigprocmask(set = EMPTY); // 接收所有信号
    // 遍历ngx_modules,调用其init_process()方法
    //  event_core: ngx_event_process_init()
    //                  ngx_epoll_init();
    //                  初始化cycle->connections,read_events,write_events
    //                  每个connection的read,write指向cycle的read_events[i],write_events[i]
    //                  connections使用connection.data当成链表串起来,free_connections指向第一个conn
    //                  然后将每个listening socket分配一个connection
    // 关闭fork时继承过来的其它process的channel[1],然后关闭掉自己的channel[0]
    ngx_add_channel_event(cycle, channel[1], NGX_READ_EVENT, ngx_channel_handler); // 监听channel[1]的READ EVENT

ngx_setproctitle("worker process"); // nginx: worker process

// 接着在一个死循环里处理exiting,quit和events timers
ngx_process_events_and_timers(cycle);
    // 同apache,php-fpm一样,如果有多个worker process,要使用shm的accept_mutex
    ngx_process_events(); => ngx_epoll_process_events();
        epoll_wait();
        // 上边 ngx_event_process_init() 时添加了两个connection,一个是listening socket,一个是channel[1]
        // listening socket的handler是ngx_event_accept, channel[1]的handler是ngx_channel_handler
        // 先看channel[1]的ngx_channel_handler()
        //      前边每fork出来一个worker process后,都write了一个channel_t,cmd=NGX_CMD_OPEN_CHANNEL,
        //      worker_process读取到channel_t后,将ngx_processes[]里对应的pid,channel[0]更新,看不出来有什么用处
        //      倒是其它的几个CMD容易理解,ngx_quit,ngx_terminate,ngx_reopen
        // 再看ngx_event_accept()
        //      调用 accept4(SOCK_NONBLOCK), 新拿到的fd是nonblock的, 然后将fd转成connection, 最后调用listening的handler,也就是 ngx_http_init_connection()
        //       ngx_http_block() -> ngx_http_optimize_servers() -> ngx_http_init_listening() -> ngx_http_add_listening()

ngx_http_init_connection();
    ngx_http_init_request();
        ngx_http_process_request_line();
            ngx_http_read_request_header();
            ngx_http_parse_request_line();
            ngx_http_process_request_headers();
                ngx_http_process_request();
                    ngx_http_handler();
</code></pre>

<h3>stream</h3>
<pre><code class="language-c">
/*
stream {
    upstream stream_backend {
        server 127.0.0.1:8888;
        server 127.0.0.1:8889;
        server 127.0.0.1:8890;
    }

    server {
        listen 127.0.0.1:8887;
        proxy_pass stream_backend;
    }
}
*/

ngx_stream_block()
    // 1
    foreach NGX_STREAM_MODULE
        create_main_conf
        create_srv_conf
        preconfiguration
    // 2
    ngx_conf_parse()
    // 3
    foreach NGX_STREAM_MODULE
        init_main_conf
            main_conf[stream_upstream].upstreams[x].peer.init_upstram();
        merge_srv_conf
    // 4
    ngx_stream_init_phases()
        array_init of handlers:
            NGX_STREAM_POST_ACCEPT_PHASE
            NGX_STREAM_PREACCESS_PHASE
            NGX_STREAM_ACCESS_PHASE
            NGX_STREAM_SSL_PHASE
            NGX_STREAM_PREREAD_PHASE
            NGX_STREAM_LOG_PHASE
    // 5
    foreach NGX_STREAM_MODULE
        postconfiguration
            NGX_STREAM_LOG_PHASE.handlers[x] = ngx_stream_log_handler;
            ngx_stream_top_filter = ngx_stream_write_filter;
    // 6
    ngx_stream_variables_init_vars();
    // 7
    ngx_stream_init_phase_handlers();
        n = 1;
        ph = ngx_pcalloc(cf->pool, n * sizeof(ngx_stream_phase_handler_t) + sizeof(void *));
        struct ngx_stream_phase_handler_t {
            ngx_stream_phase_handler_pt checker;
            ngx_stream_handler_pt       handler;
            ngx_uid_t                   next;
        }
        // NGX_STREAM_CONTENT_PHASE
        cmcf->phase_engine.handlers = ph = ph[0] = {
            checker = ngx_stream_core_content_phase;
        }
    // 8 合并listen项
    ngx_stream_add_ports();
    ngx_stream_optimize_servers();

/*
cycle->conf_ctx
| 0 core                 | -> ngx_core_conf_t
| 1 errlog               |
| 2 conf                 |
| 3 events               | -> ngx_event_modules_ctx_ptr -> ngx_event_modules_ctx
| .                      |                                 | 0 | -> ngx_event_conf_t
| .                      |                                 | 1 | -> ngx_epoll_conf_t
| .                      |
| .                      |
| 21 stream              | -> ngx_stream_conf_ctx_t
                                main_conf
                                    | stream_core       | -> ngx_stream_core_main_conf_t
                                                                servers -> array of ngx_ngx_stream_core_srv_conf_t
                                                                    {
                                                                        file_name              =
                                                                        line                   =
                                                                        resolver_timeout       = UNSET
                                                                        proxy_protocol_timeout = UNSET
                                                                        tcp_nodelay            = UNSET
                                                                        preread_buffer_size    = UNSET
                                                                        preread_timeout        = UNSET
                                                                    }
                                                                listen  -> array of ngx_stream_listen_t
                                                                    {
                                                                        sockaddr = ,
                                                                        socklen  = ,
                                                                        backlog  = NGX_LISTEN_BACKLOG,
                                                                        rcvbuf   = -1,
                                                                        sndbuf   = -1,
                                                                        type     = SOCK_STREAM,
                                                                        wildcard = ,
                                                                        ctx      =
                                                                    }
                                                                phase_engine
                                                                phases[NGX_STREAM_LOG_PHASE + 1] = {
                                                                    NGX_STREAM_POST_ACCEPT_PHASE    array of handlers
                                                                    NGX_STREAM_PREACCESS_PHASE      array of handlers
                                                                    NGX_STREAM_ACCESS_PHASE         array of handlers
                                                                    NGX_STREAM_SSL_PHASE            array of handlers
                                                                    NGX_STREAM_PREREAD_PHASE        array of handlers
                                                                    NGX_STREAM_LOG_PHASE            array of handlers
                                                                }
                                                                variables_hash_max_size    = 1024
                                                                variables_hash_bucket_size = 64
                                                                variables_keys             = NULL
                                                                variables -> array of ngx_stream_variable_t
                                                                prefix_variables -> array of ngx_stream_variable_t
                                    | stream_log        | -> ngx_stream_log_main_conf_t
                                                                formats -> array of ngX_stream_log_fmt_t
                                    | stream_proxy      | -> NULL
                                    | stream_upstream   | -> ngx_stream_upstream_main_conf_t
                                                                upstreams -> array of ngx_stream_upstream_srv_conf_t
                                                                    {
                                                                        flags     =
                                                                        host      = "stream_backend"
                                                                        file_name =
                                                                        line      =
                                                                        port      = 0
                                                                        no_port   = 1
                                                                        servers -> array of ngx_stream_upstream_server_t
                                                                            {name = "127.0.0.1:8888", addrs = , naddrs = , weight = 1, max_conns = 0, max_fails = 1, fail_timeout = 10},
                                                                            {name = "127.0.0.1:8889", addrs = , naddrs = , weight = 1, max_conns = 0, max_fails = 1, fail_timeout = 10},
                                                                            {name = "127.0.0.1:8890", addrs = , naddrs = , weight = 1, max_conns = 0, max_fails = 1, fail_timeout = 10}
                                                                        peer = {
                                                                            init_upstram
                                                                        }
                                                                    }
                                srv_conf
                                    | stream_core       | -> ngx_stream_core_srv_conf_t
                                                                handler                = ngx_stream_proxy_handler;
                                                                file_name              =
                                                                line                   =
                                                                resolver_timeout       = UNSET
                                                                proxy_protocol_timeout = UNSET
                                                                tcp_nodelay            = UNSET
                                                                preread_buffer_size    = UNSET
                                                                preread_timeout        = UNSET
                                    | stream_log        | -> ngx_stream_log_srv_conf_t
                                                                open_file_cache = UNSET
                                    | stream_proxy      | -> ngx_stream_proxy_srv_conf_t
                                                                connect_timeout       = UNSET
                                                                timeout               = UNSET
                                                                next_upstream_timeout = UNSET
                                                                buffer_size           = UNSET
                                                                upload_rate           = UNSET
                                                                download_rate         = UNSET
                                                                responses             = UNSET
                                                                next_upstream_tries   = UNSET
                                                                next_upstream         = UNSET
                                                                proxy_protocol        = UNSET
                                                                local                 = UNSET
                                                                upstream              = main_conf[stream_upstream][upstreams][0]
                                    | stream_upstream   | -> NULL

| 22 stream_core         |
| 23 stream_log          |
| 24 stream_proxy        |
| 25 stream_upstream     |
| 26 stream_write_filter |
| .                      |
| ngx_max_module - 1     |

NGX_STREAM_MODULE               preconfiguration            postconfiguration       create_main_conf            init_main_conf          create_srv_conf             merge_srv_conf
ngx_stream_core_module          ngx_sc_preconfiguration     NULL                    ngx_sc_create_main_conf     ngx_sc_init_main_conf   ngx_sc_create_srv_conf      ngx_sc_merge_srv_conf
ngx_stream_log_module           NULL                        ngx_stream_log_init     ngx_sl_create_main_conf     NULL                    ngx_sl_create_srv_conf      ngx_sl_merge_srv_conf
ngx_stream_proxy_module         NULL                        NULL                    NULL                        NULL                    ngx_sp_create_srv_conf      ngx_sp_merge_srv_conf
ngx_stream_upstream_module      ngx_su_add_variables        NULL                    ngx_su_create_main_conf     ngx_su_init_main_conf   NULL                        NULL
ngx_stream_write_filter_module  NULL                        ngx_sw_filter_init      NULL                        NULL                    NULL                        NULL
*/
</code></pre>

<h3>ngx_stream_init_connection(ngx_connection_t *c)</h3>
<pre><code class="language-c">
s = ngx_pcalloc(c->pool, sizeof(ngx_stream_session_t));
    // s->phase_handler = 0;
s->connection = c;
c->read->handler = ngx_stream_session_handler;

ngx_stream_session_handler();
    ngx_stream_core_run_phases(s);
        ph = cmcf->phase_engine.handlers; // 只有一个 ph[0].checker = ngx_stream_core_content_phase;
        while (ph[s->phase_handler].checker) {
            rc = ph[s->phase_handler].checker(s, &ph[s->phase_handler]);
            if (rc == NGX_OK) {
                return;
            }
        }

ngx_stream_core_content_phase()
    ngx_stream_proxy_handler(s)
        pscf = ngx_stream_get_module_srv_conf(s, ngx_stream_proxy_module);
        u = ngx_pcalloc(c->pool, sizeof(ngx_stream_upstream_t));
        s->upstream = u;
        c->write->handler = ngx_stream_proxy_downstream_handler;
        c->read->handler = ngx_stream_proxy_downstream_handler;
        p = ngx_pnalloc(c->pool, pscf->buffer_size);
        u->downstream_buffer.start = p;
        if (c->read->ready) {
            ngx_post_event(c->read, &ngx_posted_events);
        }
        u->upstream = pscf->upstream; // main_conf[stream_upstream][upstreams][0]
        u->upstream.peer.init();
        ngx_stream_proxy_connect(s);

// ngx_stream_proxy_handler新分配了一个ngx_stream_upstream_t,并将其设为session的upstream

struct ngx_stream_upstream_t {
    ngx_peer_connection_t peer; // 这个就是要连接的 backend server

    ngx_buf_t downstream_buf;
    ngx_buf_t upstream_buf;

    // ...

    ngx_stream_upstream_srv_conf_t *upstream = pscf->upstream; // 配置的upstream

    // ...
}

// backend server 的选择就在 u->upstream.peer.init() 这里
</code></pre>

</div>
<script src="../prism.js"></script>
</body>
</html>
