<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../bootstrap-3.3.5/css/bootstrap.min.css">
<link rel="stylesheet" href="../prism.css">
</head>
<body>
<div class="container">

<h1 class="page-header">nginx 1.1.19</h1>

<h3>modules</h3>
<pre><code class="language-c">// configure产生的#define在 objs 目录里
ngx_module_t *ngx_modules[] = {
    &ngx_core_module,
    &ngx_errlog_module,
    &ngx_conf_module,
    &ngx_events_module,
    &ngx_event_core_module,
    &ngx_epoll_module,
    &ngx_regex_module,
    &ngx_http_module,
    &ngx_http_core_module,
    // ...
    NULL
};

typedef struct ngx_module_s {
    ngx_uint_t ctx_index;
    ngx_uint_t index;

    ngx_uint_t version;

    void *ctx;
    ngx_command_t *commands;
    ngx_uint_t type;

    ngx_int_t (*init_master)(ngx_log_t *log);
    ngx_int_t (*init_module)(ngx_cycle_t *cycle);
    ngx_int_t (*init_process)(ngx_cycle_t *cycle);
    ngx_int_t (*init_thread)(ngx_cycle_t *cycle);
    void (*exit_thread)(ngx_cycle_t *cycle);
    void (*exit_process)(ngx_cycle_t *cycle);
    void (*exit_master)(ngx_cycle_t *cycle);
} ngx_module_t;

// ==== CORE MODULES ====
ngx_core_module = {
    &ngx_core_module_ctx,                  /* module context */
    ngx_core_commands,                     /* module directives */
};
ngx_errlog_module = {
    &ngx_errlog_module_ctx,                /* module context */
    ngx_errlog_commands,                   /* module directives */
};
ngx_events_module = {
    &ngx_events_module_ctx,                /* module context */
    ngx_events_commands,                   /* module directives */
};
ngx_regex_module = {
    &ngx_regex_module_ctx,                 /* module context */
    ngx_regex_commands,                    /* module directives */
    ngx_regex_module_init,                 /* init module */
};
ngx_http_module = {
    &ngx_http_module_ctx,                  /* module context */
    ngx_http_commands,                     /* module directives */
};
// ==== OTHER MODULES ====
ngx_conf_module = {
    ngx_conf_commands,                     /* module directives */
    NGX_CONF_MODULE,                       /* module type */
    ngx_conf_flush_files,                  /* exit process */
};
ngx_event_core_module = {
    &ngx_event_core_module_ctx,            /* module context */
    ngx_event_core_commands,               /* module directives */
    NGX_EVENT_MODULE,                      /* module type */
    ngx_event_module_init,                 /* init module */
    ngx_event_process_init,                /* init process */
};
ngx_epoll_module = {
    &ngx_epoll_module_ctx,               /* module context */
    ngx_epoll_commands,                  /* module directives */
    NGX_EVENT_MODULE,                    /* module type */
};
ngx_module_t  ngx_http_core_module = {
    &ngx_http_core_module_ctx,             /* module context */
    ngx_http_core_commands,                /* module directives */
    NGX_HTTP_MODULE,                       /* module type */
};
// ngx_cycle
struct ngx_cycle_s {
    void ****conf_ctx;
    ngx_pool_t *pool;

    ngx_log_t *log;
    ngx_log_t new_log;

    ngx_connection_t **files;
    ngx_connection_t  *free_connections;
    ngx_uint_t         free_connection_n;

    ngx_queue_t reusable_connections_queue;

    ngx_array_t listening;
    ngx_array_t pathes;
    ngx_list_t  open_files;
    ngx_list_t  shared_memory;

    ngx_uint_t  connection_n;
    ngx_uint_t  files_n;

    ngx_connection_t *connections;
    ngx_event_t *read_events;
    ngx_event_t write_events;

    ngx_cycle_t *old_cycle;

    ngx_str_t conf_file;            // => /path/to/nginx/conf/nginx.conf
    ngx_str_t conf_param;           // => -g 参数
    ngx_str_t conf_prefix;          // => /path/to/nginx/conf/
    ngx_str_t prefix;               // => /path/to/nginx/
    ngx_str_t lock_file;
    ngx_str_t hostname;
};
</code></pre>

<h3>main()</h3>
<pre><code class="language-c">// http://localhost/lxr/source/src/core/nginx.c?v=nginx-1.1.19#0200
ngx_strerror_init();
    // 初始化ngx_sys_errlist, NGX_SYS_NERR = 135
    // 注释里说的很清楚为什么要有ngx_sys_errlist
ngx_get_options();
    // -p => ngx_prefix
    // -c => ngx_conf_file
    // -g => ngx_conf_params
    // -s => ngx_signal, ngx_process = NGX_PROCESS_SIGNALLER

ngx_time_init();
ngx_regex_init();

ngx_pid = getpid();

ngx_log_init(ngx_prefix);
    ngx_log.file = &ngx_log_file = {.fd = open(NGX_PREFIX . "logs/error.log")};
    ngx_log.log_level = NGX_LOG_NOTICE;

init_cycle.log = &ngx_log;
ngx_cycle = &init_cycle;
init_cycle.pool = ngx_create_pool();
ngx_save_argv(); // 把argv复制一份到ngx_argv
ngx_process_options();
    init_cycle.conf_prefix = NGX_CONF_PREFIX = "conf/" => "/path/to/nginx/conf/";
    init_cycle.prefix      = NGX_PREFIX      = "/path/to/nginx/"
    init_cycle.conf_file   = NGX_CONF_PATH   = "conf/nginx.conf" => "/path/to/nginx/conf/nginx.conf";
ngx_os_init();
    ngx_os_specific_init(); // 调用uname()取得ostype,osrelease, ngx_os_io = ngx_linux_io;
    ngx_init_setproctitle(); // 把environ复制一份,上边已经把argv复制了一份,现在可以放心的修改os的argv,env了
    ngx_ncpu = sysconf(_SC_NPROCESSORS_ONLN);
    ngx_cpuinfo(); // 调用cpuid取得cacheline_size
    ngx_max_sockets = rlim_cur;
    ngx_inherited_nonblocking = 1;
ngx_crc32_table_init();
ngx_add_inherited_sockets();
// 给每个module设上index,同时也得到了module的数量 ngx_max_module
ngx_init_cycle(&init_cycle);
    /* 新创建一个cycle
       需要注意的是,虽然上边的init_cycle在没有传递-g参数的情况下,conf_param.len = 0, conf_param.data = NULL
       但是这里将init_cycle复制到新的cycle上时,conf_param又给分配了一小块内存,也就是说新的len = 0,data !=NULL 了
       初始化 pathes, open_files, shared_memory, listening, reusable_connections_queue, conf_ctx
       cycle->hostname = gethostname()
       遍历NGX_CORE_MODULE(core,errlog,events,regex,http),如果module->ctx实现了create_conf方法,则调用之
            core:   ngx_core_module_create_conf() => 分配一块内存用于ngx_core_conf_t{daemon,master,user,group...}
            errlog: 没有create_conf()方法
            events: 没有create_conf()方法
            regex:  ngx_regex_create_conf() => 分配一块内存用于ngx_regex_conf_t{pcre_jit}
            http:   没有create_conf()方法

        前边初始化的cycle->conf_ctx是个指针数组,每个module占一个位置,这里core和regex create的conf都存到conf_ctx里了

        如果传递了参数-g的话,ngx_conf_param()将会处理它,先略过
        ngx_conf_parse()来处理 /path/to/nginx/conf/nginx.conf, 只处理 NGX_CORE_MODULE和NGX_CONF_MODULE 的 NGX_MAIN_CONF
        nginx的配置文件只有两种情况: 
            1) 以;号结尾的一行配置
            2) 用{}包起来的block,block里是以;结尾的配置项
        默认配置项使用ngx_conf_handler()来处理,也可以改用其它方法. 每个配置项都有对应的一个函数来处理.
        nginx的默认配置如下:
            worker_processes 1; // ngx_core_commands -> ngx_conf_set_num_slot()
                                // ngx_core_conf_t.worker_processes = 1;
            events {            // ngx_events_commands -> ngx_events_block()
                                //    ngx_events_block()遍历ngx_modules,找到NGX_EVENT_MODULE(event_core, epoll)
                                //    调用其ctx的create_conf()方法
                                //      event_core: ngx_event_create_conf() 分配一块内存用于ngx_event_conf_t {connections,use,multi_accept,accept_mutex...}
                                //      epoll: ngx_epoll_create_conf() 分配一块内存用于ngx_epoll_conf_t {events,aio_requests}
                                //    接着调用ngx_conf_parse()解析block块
                worker_connections 1024;  // ngx_event_conf_t.connections = 1024;
                                          // cycle->connection_n = 1024;
                                //    再然后再次遍历ngx_modules,找到NGX_EVENT_MODULE,调用其init_conf()方法
                                //      event_core: ngx_event_init_conf()
                                //                  ngx_event_conf_t.use = epoll->ctx_index
                                //                                  .name = "epoll"
                                //                                  .multi_accept = 0
                                //                                  .accept_mutex = 1
                                //                                  .accept_mutex_delay = 500
                                //      epoll: ngx_epoll_init_conf()
                                //             ngx_epoll_conf_t.events = 512
                                //                             .aio_requests = 32
            }
            http {              // ngx_http_commands -> ngx_http_block()
                                //    和ngx_events_block()很相似,首先,找出来NGX_HTTP_MODULE,然后分别调用其ctx的create_main_conf,create_srv_conf,create_loc_conf方法
                                //    http_core:
                                //      ngx_http_core_main_conf_t {servers,headers_in_hash,ports...}
                                //      ngx_http_core_srv_conf_t {server_names,connection_pool_size...}
                                //      ngx_http_core_loc_conf_t {name,regex,static_locations,regex_locations...}
                                //    再调用 preconfiguration()方法 => ngx_http_variables_add_core_vars() http_host,http_user_agent,http_referer,http_cookie...
                                //    接着调用ngx_conf_parse()解析block块
                include mime.types;
                default_type application/octet-stream;
                sendfile on;
                keepalive_timeout 65;
                server {
                    listen 8080;
                    server_name localhost;
                }
                location / {
                    root html;
                    index index.html index.htm;
                }
                error_page 500 502 503 504 /50x.html
                location = /50x.html {
                    root html;
                }
            }

        配置文件处理完成后,调用CORE MODULES的init_conf方法
            core:   ngx_core_conf_t.daemon = 1
                                   .master = 1
                                   .pid = "logs/nginx.pid"
                                   .username="nobody"       // 如果以root用户启动的话
                                   .user = nobody uid       // 如果以root用户启动的话
                                   .group = nobody gid      // 如果以root用户启动的话
                                   .lock_file = "logs/nginx.lock"
                    cycle->lock_file = "logs/nginx.lock.accept"
            errlog: 没有init_conf()方法
            events: 没有init_conf()方法
            regex:  ngx_regex_conf_t.pcre_jit = 0
            http:   没有init_conf()方法
    */

    /* 小结一下:
        nginx首先遍历并调用CORE MODULES的create_conf方法,给每个module的配置项分配存储空间.
        然后解析配置文件,当遇到{}block时,block的command会遍历并调用与其关联的module的create_conf方法,给每个配置项分配存储空间,
        接着解析{}block块中的配置,完成后再次遍历并调用与其关联的module的init_conf方法.
        最后,调用CORE MODULES的init_conf方法,完成配置文件的解析.
     */

        ngx_test_lockfile(); // 由于 NGX_HAVE_ATOMIC_OPS = 1, 所以这个方法直接返回OK了. 用的是gcc的sync_fetch_*

        ngx_create_pathes();
            // cycle->pathes有5个,client_body_temp,proxy_temp,fastcgi_temp,uwsgi_temp,scgi_temp
            // 如果这5个目录不存在,则创建,如果存在并且是以root用户启动的,则检查owner和权限是否和配置的一样,如果不一样chown,chmod

        // 接下来open了access.log和error.log
        //create shared_memory 先略过

        ngx_open_listening_sockets(); // socket() -> bind() -> listen()
        ngx_configure_listening_sockets(); // setsockopt() rcvbuf,sndbuf,keepalive...

        // 把STDERR重定向到error.log

        // 遍历ngx_modules,调用其init_module()方法
        //  regex:      ngx_regex_module_init, 没用过regex,不清楚做什么的
        //  event_core: ngx_event_module_init, 主要是检查下worker_connections的配置是否大于当前用户可以open的文件数量
        //                                     然后就是初始化了ngx_accept_mutex和ngx_connection_counter

        // OK,到此,新创建的这个cycle初始化完成了,原来的那个cycle(init_cycle)可以丢掉了.

ngx_os_status();
        // 如果error.log配置的是notice的话,这里会打印出 nginx version, built by, ostype, osrelease, rlimit_nofile

ngx_process = NGX_PROCESS_MASTER;

ngx_init_signals(); // 绑定signal handler -> ngx_signal_handler
ngx_daemon(); // daemonize, 并重定向STDIN,STDOUT到/dev/null
ngx_daemonized = 1;

ngx_create_pidfile();
</code></pre>

<h3>ngx_master_process_cycle(cycle);</h3>
<pre><code class="language-c">// 首先,block住几个signal
ngx_setproctitle(); // nginx: master process ./sbin/nginx

typedef struct {
    ngx_pid_t pid;
    int status;
    ngx_socket_t channel[2];

    ngx_spawn_proc_pt proc;
    void *data;
    char *name;

    unsigned respawn:1;
    unsigned just_spawn:1;
    unsigned detached:1;
    unsigned exiting:1;
    unsigned exited:1;
} ngx_process_t;
ngx_process_t ngx_processes[NGX_MAX_PROCESSES=1024];

ngx_start_worker_processes(cycle, ccf->worker_processes = 1, NGX_PROCESS_RESPAWN);
    ngx_spawn_process(cycle, ngx_worker_process_cycle, NULL, "worker_process", type = NGX_PROCESS_RESPAWN);
    // ngx_last_process记录着worker process的数量,最大值是1024
    // 给process创建一个socketpair, ngx_process_t.channel[2]
    //      channel[0]: FIONBIO FIOASYNC, F_SETOWN=ngx_pid, F_SETFD=FD_CLOEXEC
    //      channel[1]: FIONBIO         ,                   F_SETFD=FD_CLOEXEC
    // socketpair好了之后,fork()
    //      fork出来的子进程更新ngx_pid为其自己的pid,然后调用ngx_worker_process_cycle(cycle, data = NULL)不再返回
    //      父进程继续执行,在ngx_processes里记录这个进程的pid,name等信息,并设respawn=1

    ngx_pass_open_channel(cycle, channel = {command=NGX_CMD_OPEN_CHANNEL,pid,slot,fd});
    // 将channel_t写到socketpair[0]里,还不知道有什么用

ngx_start_cache_manager_processes(cycle, 0); // 先略过

// 然后在一个死循环中等待signal
sigsuspend(&set = EMPTY);
// man sigsuspend()可知, sigsuspend()返回后,sig mask又恢复了
// 也就是说,你可以给nginx发信号,但nginx收到第一个后,就不再收第二个了,直到它处理完第一个信号后,又sigsuspend()时才可以再处理其它信号
</code></pre>

<h3>ngx_worker_process_cycle(cycle, data = NULL)</h3>
<pre><code class="language-c">ngx_process = NGX_PROCESS_WORKER;
ngx_worker_process_init(cycle, 1);
    ngx_set_environment(); // nginx.conf里可以添加env变量,在这里将这此变量加到environ里
    setrlimit();
    setgid(); // 如果以root权限启动
    setuid(); // 如果以root权限启动
    chdir();
    sigprocmask(set = EMPTY); // 接收所有信号
    // 遍历ngx_modules,调用其init_process()方法
    //  event_core: ngx_event_process_init()
    //                  ngx_epoll_init();
    //                  初始化cycle->connections,read_events,write_events
    //                  每个connection的read,write指向cycle的read_events[i],write_events[i]
    //                  connections使用connection.data当成链表串起来,free_connections指向第一个conn
    //                  然后将每个listening socket分配一个connection
    // 关闭fork时继承过来的其它process的channel[1],然后关闭掉自己的channel[0]
    ngx_add_channel_event(cycle, channel[1], NGX_READ_EVENT, ngx_channel_handler); // 监听channel[1]的READ EVENT

ngx_setproctitle("worker process"); // nginx: worker process

// 接着在一个死循环里处理exiting,quit和events timers
ngx_process_events_and_timers(cycle);
    // 同apache,php-fpm一样,如果有多个worker process,要使用shm的accept_mutex
    ngx_process_events(); => ngx_epoll_process_events();
        epoll_wait();
        // 上边 ngx_event_process_init() 时添加了两个connection,一个是listening socket,一个是channel[1]
        // listening socket的handler是ngx_event_accept, channel[1]的handler是ngx_channel_handler
        // 先看channel[1]的ngx_channel_handler()
        //      前边每fork出来一个worker process后,都write了一个channel_t,cmd=NGX_CMD_OPEN_CHANNEL,
        //      worker_process读取到channel_t后,将ngx_processes[]里对应的pid,channel[0]更新,看不出来有什么用处
        //      倒是其它的几个CMD容易理解,ngx_quit,ngx_terminate,ngx_reopen
        // 再看ngx_event_accept()
        //      调用 accept4(SOCK_NONBLOCK), 新拿到的fd是nonblock的, 然后将fd转成connection, 最后调用listening的handler,也就是 ngx_http_init_connection()
        //       ngx_http_block() -> ngx_http_optimize_servers() -> ngx_http_init_listening() -> ngx_http_add_listening()



ngx_http_init_connection();
    ngx_http_init_request();
        ngx_http_process_request_line();
            ngx_http_read_request_header();
            ngx_http_parse_request_line();
            ngx_http_process_request_headers();
                ngx_http_process_request();
                    ngx_http_handler();
</code></pre>

</div>
<script src="../prism.js"></script>
</body>
</html>
