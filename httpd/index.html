<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="bootstrap-3.3.5/css/bootstrap.min.css">
<link rel="stylesheet" href="prism.css">
</head>
<body>
<div class="container">

<h1 class="page-header">Apache httpd 2.2.31</h1>

<h3>bin/apachectl</h3>
<pre><code class="language-bash">load evnvars # LD_LIBRARY_PATH, 加上httpd自己的lib目录
ulimit -S -n `ulimit -H -n` # man bash
                            # ulimit -n 用于修改允许打开的fd数量,-H 是 hard limit, -S 是 softlimit
                            # 这个命令把允许打开的fd数量提到最高

# httpd的几种调用方式
httpd -h
httpd -k start|stop|restart|graceful|graceful-stop
httpd -t
</code></pre>

<h3>源码分析</h3>
@see The Apache Modules Book: Application Development with Apache (Nick Kew) <br>
@see http://dev.ariel-networks.com/apr/apr-tutorial/html/apr-tutorial.html <br>
<span style="color:red">apr_bucket_type_* 在apr-util里</span><br><br>

server/main.c#0442
<pre><code class="language-c">init_process(&argc, &argv); // 初始化apr,创建一个pool和subpool pconf, 初始化process_rec
struct process_rec {
    apr_pool_t *pool;
    apr_pool_t *pconf; // apr_pool_create(&process->pconf, process->pool);
    int argc;
    const char * const *argv;
    const char *short_name;
}

ap_setup_prelinked_modules(process);
    // 编译时static编译的module列表在modules.c里,这个文件是./configure时生成的
    // ./apachectl -t -D DUMP_MODULES 可以查看loaded modules
    struct module_struct {
        int version, minor_version;     // MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR
        int module_index;               // -1
        const char *name;               // __FILE__
        void *dynamic_load_handle;      // NULL
        struct module_struct *next;     // NULL
        unsigned long magic;            // MODULE_MAGIC_COOKIE
        ...
        const command_rec *cmds;
        void (*register_hooks)(apr_pool_t *p);
    };
    // module声明时 module_index = -1, 这里遍历一次ap_preloaded_modules,把module_index给设上.
    // 除了preloaded module外,还有dynamic module,默认限制dynamic module最多有128个
    // ap_loaded_modules是一个最后一项为NULL的指针数组
    ap_add_module(*module, process->pconf);
        // 在这里把所有preloaded module通过module->next形成了一个单链表
        // NULL &lt;- core_module &lt;- authn_file_module &lt;- ... &lt;- so_module
        ap_add_module_commands(module, pconf);
        struct command_struct {
            const char *name;
            cmd_func func;
            ...
        };
        // apache所有module实现的指令(httpd.conf里的配置指令)都保存在ap_config_hash里,
        // hash key是cmd的名字,value是struct ap_mod_list_struct {module *m; const command_rec *cmd; *next}
        // 所以不同module的cmd name可以重复,是能区分开的
        ap_register_hooks(module, pconf);
        // 调用module->register_hooks(p)方法注册module添加的hook方法
        apr_hook_sort_all(); // 没看明白

        /* ap_add_module随后也用于add dynamic module, 看下LoadModule的实现
           @see modules/mappers/mod_so.c#0147
           @see man dlopen
           mod_so.c load_module()调用apr_dso_load把.so文件加载到内存,apr_dso_load在linux上其实就是dlopen
           然后apr_dso_sym查找到module AP_MODULE_DECLARE_DATA XXX_module的内存地址,
           再调用ap_add_loaded_module,ap_add_loaded_module调用了ap_add_module
        */

ap_run_rewrite_args(process);
    // 调用module->rewrite_args(process),在刚开始初始化process时,把argc,argv都放到process里了,module可以在这里re-write command line arguments
    // struct module_struct的注释里写的很清楚, This hook is only available to MPMs.
    // 看下 server/mpm/prefork/prefork.c#1499, ap_mpm_rewrite_args定义在 server/mpm_common.c#1067
    // ./httpd -k start|stop|restart 的-k参数就是在这里处理的, -k参数的值记录在dash_k_arg里

// 接下来处理命令行参数,就是 ./httpd -h看到的那些,我们只关心-k,所以这部分跳过

server_rec *server_conf = ap_read_config(process, pool_temp, confname="conf/httpd.conf", &ap_conftree);
    init_server_config(); // 分配并初始化一个server_rec
                          // server_rec->module_config是一个指针数组,它为每个可能的module都预留一个位置,
                          // 如果module实现了create_server_config方法,就会调用它并把返回结果保存在这里
                          // server_rec->lookup_defaults和module_config一样,
                          // 如果module实现了create_dir_config,就会调用它并把返回结果保存在lookup_defaults里
    init_config_globals(); => ap_init_vhost_config();
        // 这个函数就是把iphash_table清0,别的没做啥值得关注的
        // ap_init_vhost_config的注释里解释了vhost是怎么组织和管理的
        // vhost分两种,一种是ip-based,一种是name-based
        // ip-based vhost通过一个hashtable iphash_table[256]管理
        // name-based vhost首先是一个ip-based vhost,然后再用一个name_chain单链表把同一ip:port下的vhost串起来
        // 还有两个变量 default_list 和 name_vhost_list 还不知道有什么用
    process_command_config(ap_server_pre_read_config); // ./httpd -C directive, 我们不关心这个,跳过去
    ap_server_root_relative("conf/httpd.conf");
    // 默认的ap_server_root = HTTPD_ROOT = "/usr/local/apache"
    // 如果在./configure的时候指了prefix,那么HTTPD_ROOT = prefix
    ap_process_resource_config("/path/to/conf/httpd.conf");
    // 看起来apache的配置文件可以使用通配符,我们的只关心普通的一个配置文件的情况
        process_resource_config_nofnmatch("httpd.conf", depth = 0);
            ap_build_config();
            // 读取httpd.conf文件,一次读一行,解析出directive
            // 根据cmd->req_override决定是立即执行对应的函数还是把这个directive加到conftree里
            // 以ServerRoot举例:
            // Line 30: ServerRoot "/path/to/httpd"
            struct ap_directive_t {
                const char *filename;   // httpd.conf
                int line_num;           // 30
                const char *directive;  // ServerRoot
                const char *args;       // "/path/to/httpd"
                ap_directive_t *next;
                ap_directive_t *first_child;
                ap_directive_t *parent;
            }
            AP_INIT_TAKE1("ServerRoot", set_server_root, NULL, RSRC_CONF | EXEC_ON_READ,
                                    "Common directory of server-related files (logs, confs, etc.)")
            // req_override = RSRC_CONF | EXEC_ON_READ, 所以读取到这一行时立即执行了set_server_root方法
    process_command_config(ap_server_post_read_config); // ./httpd -c directive, 跳过去

ap_run_pre_config() // 不知道在哪里定义的,跳过去

ap_process_config_tree(server_conf, ap_conftree, apr_pool_t);
    // 上边ap_read_config时没有执行的directive,在这里都给执行了

ap_fixup_virtual_hosts();
    // 先看下NameVirtualHost和VirtualHost
    // NameVirtualHost *:80 => ap_set_name_virtual_host(),生成一个server_addr_rec并加到name_virtual_list里.
    // &lt;VirtualHost *:80&gt; => virtualhost_section(),生成一个server_rec,根据*:80也生成一个server_addr_rec并设给server_rec->addrs.
    //  这个server_rec的is_virtual = 1, module_config和lookup_defaults是空的指针数组
    //  最后把这个server_rec和main_server连起来,并执行VirtualHost里的directive
    /*
        ap_fixup_virtual_hosts主要做的事就是merge_config, 如果virtual_host里对应module的config是空的,
        就设成和main_server一样,如果不为空,就调用module的merge_方法做merge
    */
ap_fini_vhost_config();
</code></pre>

小结:
<p>
httpd是由module组成的,每个module给httpd贡献了一部分httpd里的配置项(cmd/directive)和一些hooks.<br>
module可以静态编译进httpd,也可以在httpd启动时加载进来.<br>
httpd当前包含的module记录在全局变量ap_loaded_modules里.<br>
module->cmds是一个类似argv的指针数组,它的最后一项为NULL,每一个cmd都有一个名称和对应的执行函数.<br>
所有module的cmd会合并到一块,保存在全局变量ap_config_hash里,key是cmd的名字,value是module的cmd串起来的单链表.
</p>
<p>httpd默认支持一些命令行参数,module也可以添加自己的命令行参数,比如prefork的 -k start|stop|restart.</p>
<p>
默认的httpd.conf提供了一个global server/main server,其host_addr=0.0.0.0,host_port=0,virthost="".<br>
main server初始化时会调用每个module的create_server_config方法,将每个module的server config保存在server->module_config里.<br>
同时还调用module的create_dir_config方法,将每个module的directive config保存在server->lookup_defaults里.<br>
<p>
httpd会先过一遍httpd.conf,识别出其中的配置项,如果这个cmd是要求当即执行的,那就到ap_config_hash里找到对应的执行函数,执行之.如果不需要当即执行,就加到conftree里,后边再执行.<br>
举两个实际的例子:<br>
mod_core的ServerRoot cmd是要求EXEC_ON_READ的,httpd读到这个配置项时,会立即调用对应的set_server_root()方法将ap_server_root赋值.<br>
mod_so的LoadModule cmd也是要求EXEC_ON_READ的,httpd读到这个配置项时,会立即调用load_module方法加载指定的so文件.<br>
mod_so也是一个server_config使用的例子,它为了记录下都加载了哪些module,在main server初始化调用create_server_config时,分配了一个数组来保存已加载的module,然后在load_module()里通过访问server->module_config[mod_so->module_index]就拿到了这个数组,从而可以做检查判断.<br>
mod_so在加载完module后,会调用该module的create_server_config和create_dir_config方法.
</p>
<p>
httpd过完httpd.conf后,conftree有了,紧接着再过一遍conftree,把没有执行的cmd都给执行一下.<br>
<pre><code class="language-c">// @see http://httpd.apache.org/docs/2.2/vhosts/details.html
// 看下几个感兴趣的directive:

ServerName [scheme://]fully-qualified-domain-name[:port]
server_hostname_port() // 解析出scheme,hostname,port分别赋值给server_rec->server_scheme,server_hostname,port
                       // 如果启动时报Could not reliably determine the server's fully qualified domain name, using 127.0.0.1 for ServerName
                       // 简单地在httpd.conf里加上ServerName配置或者给本机配置一个带.的hostname就好了
                       // @see ap_fini_vhost_config()
                       // @see ap_get_local_host()

Listen [IP-address:]portnumber [protocol] // Listen是prefork mpm的cmd,定义在include/ap_listen.h#0115里,对应的function是ap_set_listener
ap_set_listener()
    // ap_set_listener()其实就是调用一下int socket(int domain, int type, int protocol),并把多个Listen创建的socket放到单链表ap_listeners里.

NameVirtualHost addr[:port]
ap_set_name_virtual_host() // 解析出addr,port,生成server_addr_rec,加到name_vhost_list单链表里
                           // 比如NameVirtualHost *:80会生成host_addr=0.0.0.0,host_port=80,virthost=*

VirtualHost addr[:port] [addr[:port]]
virtualhost_section()
    ap_init_virtual_host(); => ap_parse_vhost_addrs();
    // 创建一个server_rec,根据VirtualHost的参数填充server_rec->addrs,并把第一个addr的port设成server的port
    // 这里特别提一下: 这个新的server_rec的module_config和lookup_defaults都是空的
    // 新创建的这个server_rec会和main_server串连在一起形成一个单链表
    ap_walk_config();
    // 上边我们知道这个新server_rec的module_config和lookup_defaults都是空的,这里walk_config时,
    // 当执行到一个module的cmd之前,会调用module的create_server_config和create_dir_config方法
    // 把server_rec的module_config和lookup_defaults都初始化好,接下来的cmd就可以正常执行了.
</code></pre>
httpd在读取并执行完httpd.conf里的配置指令后,就定下来了所有的virthost.<br>
由于VirtualHost里的配置指令显然比较少,所以现在virthost的配置相比main_server是不完整的,所以接下来的ap_fixup_virtual_hosts会把main_server里各个module的配置merge到virthost里去.这个每个virthost都独立并且完整了.<br>
httpd对server的分类有两种:<br>
1) NameVirtualHost *:port<br>
2) NameVirtualHost ip:port<br>
第1种是我们常用的,第2种不怎么用.<br>
上边我们知道httpd在读取配置文件时每遇到一个NameVirtualHost addr:port指令就生成一个server_addr_rec保存到name_vhost_list里.<br>
httpd在ap_fini_vhost_config()时遍历name_vhost_list,把*:port的归类的default_list里,把ip:port的放到iphash_table里.<br>
然后遍历所有的virthost,如果是VirtualHost *:port,就先按port归类vhost,再把同一个port的vhost串起来.<br>
<pre>
 ___________________        ____________________        ____________________
|                   |      |                    |      |                    |
| virthost *:port1  |  ->  | virthost *:port2   |  ->  | virthost *:port3   |
| server(hostname)  |      | server(hostname)   |      | server(hostname)   |
        |   __________________       ___________________
        |__|                  |     |                   |
           | virthost *:port1 |  -> | virthost *:port1  |
           | server(hostname) |     | server(hostnam)   |
</pre>
</p>
<p style="color:red">OK, 到此httpd已经读取并执行完了所有的配置指令,所有virthost的配置都ready了,并且组织好了virthost的数据结构.</p>
<br><br>

<pre><code class="language-c">APR_RETRIEVE_OPTIONAL_FN(ap_signal_server); => apr_dynamic_fn_retrieve(ap_signal_server);
// 不太明白怎么个调用关系,看起来应该是调用了server/mpm_common.c#0978的ap_signal_server()函数
int ap_signal_server(int *exit_status, apr_pool_t *pconf);
// 首先尝试读取ServerRoot/logs/httpd.pid文件,这个文件的存放路径定义在server/mpm/prefork/mpm_default.h#0056,
// mpm prefork在注册它的hooks时调用了prefork_pre_config()方法,在这里赋值了ap_pid_fname
// ap_read_pid()定义在server/log.c#0823
/* 如果httpd.pid文件不存在,那么httpd尚未启动,如果文件存在,通过kill(pid,0)来探测一下看是否真的已经启动了.
   前边我们知道命令行参数-k start|stop|restart已经保存在dash_k_arg里了,这里开始执行对应的操作
   start: 如果已经启动了,直接返回1,然后退出,否则返回0,继续向下执行
   stop:  如果已经启动了,发送信号SIGTERM,否则直接返回1
   restart: 如果已经启动了,发送信号SIGHUP,然后退出,否则返回0,继续执行
   graceful: 发送信号AP_SIG_GRACEFUL=SIGUSR1
   graceful-stop: prefork不支持graceful-stop
*/

// 接下来的一个for(;;)循环应该是在处理restart这样的逻辑,关键在ap_mpm_run
</code></pre>
<br><br>

<code>int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s);</code>
<pre><code class="language-c">/* prefork module 定义了以下几个配置指令
User, Group, ChrootDir: 这三个指令填充了变量 unixd_config
Listen指令前边我们已经看过了,它就是创建socket,然后保存到ap_listeners里
其它的几个指令就是简单的赋值操作:
    ListenBacklog       => ap_listenbacklog
    SendBufferSize      => send_buffer_size
    ReceiveBufferSize   => receive_buffer_size
    StartServers        => ap_daemons_to_start
    MinSpareServers     => ap_daemons_min_free
    MaxSpareServers     => ap_daemons_max_free
    MaxClients          => ap_daemons_limit
    ServerLimit         => server_limit
*/

/* 在继续往下看之前,先看下httpd的hooks实现.

相关的文件有3个: server/config.c include/http_config.h include/ap_config.h
我们把server/config.c里与hook相关的代码单独copy出来,然后clang -E hook.c预处理好,再用indent工作做下格式化,
就得到了macro展开后的代码.
*/
static struct
{
  apr_array_header_t *link_header_parser;
  apr_array_header_t *link_pre_config;
  apr_array_header_t *link_post_config;
  apr_array_header_t *link_open_logs;
  apr_array_header_t *link_child_init;
  apr_array_header_t *link_handler;
  apr_array_header_t *link_quick_handler;
  apr_array_header_t *link_optional_fn_retrieve;
  apr_array_header_t *link_test_config;
} _hooks;

void
ap_hook_header_parser (ap_HOOK_header_parser_t * pf,
		       const char *const *aszPre, const char *const *aszSucc,
		       int nOrder)
{
  ap_LINK_header_parser_t *pHook;
  if (!_hooks.link_header_parser)
    {
      _hooks.link_header_parser =
	apr_array_make (apr_hook_global_pool, 1,
			sizeof (ap_LINK_header_parser_t));
      apr_hook_sort_register ("header_parser", &_hooks.link_header_parser);
    }
  pHook = apr_array_push (_hooks.link_header_parser);
  pHook->pFunc = pf;
  pHook->aszPredecessors = aszPre;
  pHook->aszSuccessors = aszSucc;
  pHook->nOrder = nOrder;
  pHook->szName = apr_hook_debug_current;
  if (apr_hook_debug_enabled)
    apr_hook_debug_show ("header_parser", aszPre, aszSucc);
}

apr_array_header_t *
ap_hook_get_header_parser (void)
{
  return _hooks.link_header_parser;
}

int
ap_run_header_parser (request_rec * r)
{
  ap_LINK_header_parser_t *pHook;
  int n;
  int rv;
  if (!_hooks.link_header_parser)
    return OK;
  pHook = (ap_LINK_header_parser_t *) _hooks.link_header_parser->elts;
  for (n = 0; n < _hooks.link_header_parser->nelts; ++n)
    {
      rv = pHook[n].pFunc (r);
      if (rv != OK && rv != DECLINED)
	return rv;
    }
  return OK;
}
/*
可以看到struct _hooks使用数组归类hook,当第一次向一个类别里注册hook时,会创建数组.
不同类别的hooks运行要求是不同的,比如header_parser的hook返回OK或DECLINED时,继续执行其它hook,否则就直接返回了.
而child_init则会运行所有的hook, handler和quick_handler的hook返回DECLINED时会继续执行其它hook,否则直接返回.

hook归类                    什么情况下执行其它hook
header_parser               OK/DECLINED
pre_config                  OK/DECLINED
post_config                 OK/DECLINED
open_logs                   OK/DECLINED
child_init                  总是执行其它hook
handler                     DECLINED
quick_handler               DECLINED
optional_fn_retrieve        总是执行其它hook
test_config                 总是执行其它hook
*/

/*
现在再回过头来看httpd的启动流程:
    httpd一启动,在ap_add_module时把每个module的cmd和hooks就都add了.
    接着read config后,process config tree之前,调用了ap_run_pre_config(),这里把pre_config的hooks都执行了.
    process config tree之后,调用了ap_run_open_logs()把open_logs的hooks都执行了.
    紧接着就是ap_run_post_config()把post_config的hooks都执行了.

    prefork module注册了两个hook:
    open_logs:  prefork_open_logs
    pre_config: prefork_pre_config
*/
prefork_pre_config();   // 就是初始化一些全局变量,没有什么特别值得关注的
prefork_open_logs();
    ap_server_conf = server_conf;
    ap_setup_listeners(); // 前边的process config tree时,每遇到一个Listen指令,我们create了一个socket并记录到ap_listeners链表中
                          // 这里遍历ap_listener,执行bind,listen操作
                          // OK,到此,httpd server的socket已经ready了,下一步就是accept connection了.
                          /* 这里回顾一下socket/tcp相关的知识
                            man 2 listen
                            man 7 tcp
                            tcp连接的建立需要三步: 
                                1) client发送syn
                                2) server回复ack/syn
                                3) client回复ack
                            连接建立
                            kernel对每个socket维护两个queue,一个叫syn_backlog,另一个叫backlog
                            当server收到client的syn后,回复ack/syn并把这个连接放到syn_backlog里(这个queue默认大小是2048).
                            当server收到client的ack后,把这个连接从syn_backlog转到backlog里(这个queue默认大小是128).
                            然后就等着accept了.
                            如果服务器程序accept速度慢了,导致backlog queue满了,kernel会通知client端ECONNREFUSED.(这种情况下kernel会直接drop掉这个连接吗?)
                            如果服务器程序accept正常,但是有很多client没能及时回复ack导致syn_backlog满了的话,kernel就开始droping request.
                            也就是说,新的client发送syn给server时,server就不回复ack/syn了.
                          */
    ap_mpm_pod_open();  // create了一个pipe,并且closeonexec,不知道做什么用的
</code></pre>

<pre><code class="language-c">ap_log_pid(); // 把httpd的pid写入到logs/httpd.pid里
apr_proc_mutex_create(&accept_mutex, ap_lock_fname, ap_accept_lock_mech, _pconf);
    // libapr ./configure之后,在include/apr.h里可以看到APR_USE_SYSVSEM_SERIALIZE=1,所以在mutex机制是default时,优选sysvmem
    // @see The Linux Programming Interface Chapter 45: INTRODUCTION TO SYSTEM V IPC
    // mutex_create其实就是semget,mutex_acquire其实就是semop(-1),mutex_release其实就是semop(+1)
ap_run_pre_mpm(pool, SB_SHARED); // server/scoreboard.c里定义了新的hook归类, pre_mpm
                                // 目前只有module core注册一个hook函数: ap_create_scoreboard
                                ap_create_scoreboard(pool, sb_type = SB_SHARED)
                                    ap_calc_scoreboard_size(); // sizeof(global_score)
                                                               // + sizeof(process_score) * server_limit
                                                               // + sizeof(worker_score) * server_limit * thread_limit
                                                               // + sizeof(lb_score) * lb_limit
                                    open_scoreboard(); => apr_shm_create(&ap_scoreboard_shm, scoreboard_size);
                                    ap_init_scoreboard();
                                        ap_scoreboard_image = calloc(1, sizeof(scoreboard) + server_limit * sizeof(worker_score *));
                                        struct scoreboard {
                                            global_score *global;
                                            process_score *parent;
                                            worker_score **servers;
                                            lb_score *balancers;
                                        };
                                        // ap_scoreboard_image是一个struct scoreboard加上server_limit个worker_score指针
                                        // ap_scoreboard_shm = [
                                        //      image.global        global_score
                                        //      image.parent        process_score * server_limit
                                        //      image.servers
                                        //      image.balancers
                                        //  ]
                                        // 小结下: ap_scoreboard_image是一个struct scoreboard, 后边紧跟一堆worker_score指针
                                        //        真正的数据存储在ap_scoreboard_shm里

set_signals(); // install stop/restart signal handler
startup_children(remaining_children_to_start);
    make_child();  // 在ap_scoreboard_image里标记这个server(child)状态为SERVER_STARTING
                   // fork出多个children,每个child开始执行child_main()
// parent process接下来在一个死循环里wait exit的child,创建新的child以及响应stop/restart操作
</code></pre>
<br>
<br>
<br>


<code>child_main();</code>
<pre><code class="language-c">apr_proc_mutex_child_init(&accept_mutex, ap_lock_fname, pchild);
    // apr_proc_mutex_unix_lock_methods_t定义在 include/arch/unix/apr_arch_proc_mutex.h里
    // sysvsem的child_init是个空函数
unixd_setup_child(); // 切换User,Group,ChrootDir
ap_run_child_init(); // 执行各个module注册的child_init hooks
                     // prefork自身没有注册child_init hooks
                     // module_core注册了一个ap_logs_child_init()方法,这个方法close了read_handles,不清楚read_handles做什么用的
ap_update_child_status(SERVER_READY); // 在ap_scoreboard_image里标记这个server(child)状态为SERVER_READY

// 如果有多个Listen指令,使用poll来确定哪一个有client connect了
// 大多数情况下只有一个Listen 80,所以就用不上poll了
// 由于我们有多个child,所以使用了accept_mutex,使得同一时间只有一个child能accept
lr->accept_func() => unixd_accept();

conn_rec *current_conn = ap_run_create_connection(pool, ap_server_conf, accepted_socket, ....);
    // include/http_connection.h, server/connection.c 里新定义了几个hook:
    //  create_connection       -> module core: core_create_conn
    //  pre_connection          -> module core: core_pre_connection
    //  process_connection      -> module http: ap_process_http_connection
    //                          -> module echo: process_echo_connection
    //                          -> module reqtimeout: reqtimeout_init
    core_create_conn();
        // 创建一个conn_rec, update child status => SERVER_BUSY_READ
        // 取得local_ip,remote_ip
        // c->base_server = ap_server_conf = server_conf;
        // c->id = id = child_num
        // c->bucket_alloc = apr_bucket_alloc_create(pchild);
ap_process_connection();
    ap_update_vhost_given_ip();
        find_default_server(port);
        conn->vhost_lookup_data = virthost->names;
        conn->base_server = virthost;
        // 当前请求对应的是哪个VirtualHost确定下来了
        // 对于 VirtualHost *:80 这种常见的用法,也相当于没有定下来
    ap_run_pre_connection()
        core_pre_connection();
            ap_add_input_filter_handle(ap_core_input_filter_handler);
            ap_add_output_filter_handler(ap_core_output_filter_handler);
    ap_run_process_connection()
        ap_process_http_connection();
            ap_read_request()
            // update child status => SERVER_BUSY_WRITE
            ap_process_request();
            // update child status => SERVER_BUSY_KEEPALIVE
ap_lingering_close(); // close connection
</code></pre>

<code>ap_read_request(conn_rec *conn);</code>
<pre><code class="language-c">r = apr_pcalloc(pool, sizeof(request_rec));
r->conn = conn;
r->server = conn->base_server;
r->allowed_methods = ap_make_method_list(pool, 2); // GET,POST?

r->headers_in       = apr_table_make(pool, 25);
r->subprocess_env   = apr_table_make(pool, 25);
r->headers_out      = apr_table_make(pool, 12);
r->err_headers_out  = apr_table_make(pool, 5);

r->output_filters = r->proto_output_filters = conn->output_filters;
r->input_filters  = r->proto_input_filters  = conn->input_filters;

ap_run_create_request(r);
    // module_core: core_create_req
    // module_http: http_create_request
        ap_add_output_filter_handle: byterange, content_length, http_header, http_outerror

read_request_line(r, brigade); // 两种异常结果: 1) REQUEST_URI_TOO_LARGE 2) REQUEST_TIME_OUT
    r->the_request = "GET / HTTP/1.1"
    r->method = "GET";
    r->method_number = "GET" =>  M_GET
    ap_parse_uri(r, uri = "/");
        r->unparsed_uri = uri;
        apr_uri_parse(pool, uri, &r->aprsed_uri);
        // sets r->args to rest after '?' (or NULL if no '?')
        // sets r->uri to request uri (without r->args part)
        // sets r->hostname (if not set already) from request (scheme://host:port)
    r->protocol = "HTTP/1.1"
    r->proto_num = HTTP_VERSION(1, 1)
ap_get_mime_headers_core(r, brigade);
    apr_table_addn(r->headers_in, field, value);
    apr_table_compress(r->headers_in, APR_OVERLAP_TABLES_MERGE);
apr_table_get(r->headers_in, "Transfer-Encoding"); // If a Transfer-Encoding header field is
                                                   // present in a request and the chunked transfer coding is not
                                                   // the final encoding ...; the server MUST respond with the 400
                                                   // (Bad Request) status code and then close the connection

ap_update_vhost_from_headers(r);
    r->hostname = apr_table_get(r->headers_in, "Host");
    check_hostalias(r); // 在ap_process_connection的开始,httpd根据port找到了server及names
                        // 这里遍历names找到与Host header相匹配的,确定下来r->server

ap_add_input_filter_handle(ap_http_input_filter_handle);

ap_run_post_read_request(r);
    // mod_auth_digest
    // mod_reqtimeout
    // mod_headers
    // mod_setenvif
    // mod_unique_id
</code></pre>
小结一下: ap_read_request()读取并解析http请求的header头部分,匹配出vhost,创建好request_rec.<br>
如果要keepalive,则处理完这个请求后继续read next request,否则断掉这个connection.<br>
mpm里的MaxRequstsPerChild指的是connection,不是request.<br><br>

<code>ap_process_request(conn_rec *conn);</code>
<pre><code class="language-c">ap_run_quick_handler(r, 0);
// mod_cache: cache_url_handler
// IF Quick handler DECLINED
    ap_process_request_internal(r);
        ap_location_walk(r);        // Location,LocationMatch
        ap_run_translate_name(r);
        // mod_core: ap_core_translate => r->filename = documentRoot + uri
        // mod_alias: translate_alias_redir
        // mod_rewrite: hook_uri2file
        ap_run_map_to_storage(r);
        // mod_core: core_map_to_storage
        ap_location_walk();
        ap_run_header_parser();
        // mod_setenvif: match_headers
        ap_run_access_checker()
        ap_run_check_user_id()
        ap_run_auth_checker()
        ap_run_type_checker()
        /* mod_mime: find_ct
            mod_mime在post_config hook里读取conf/mime.types把文件扩展名和mime type的关系放到hashtable mime_type_extensions里
            AddType,AddEncoding,AddHandler等指令会填充conf->extension_mappings
            通过AddType添加到extension_mappings的ext优先级要比mime_type_extensions里的高
            find_ct首先在conf->extension_mappings里根据扩展名查找extinfo. 
            这里我们比较关心handler,通过AddHandler指令可以把一个文件扩展名和handler关联起来.
        */
        ap_run_fixups();
    // IF OK
    ap_invoke_handler(r);
        ap_run_insert_filter();
        invoke_filter_init(r->input_filters);
        invoke_filter_init(r->output_filters);
        r->handler = handler = r->content_type || ap_default_type() "text/plain"
        ap_run_handler(r);
        // mod_core: default_handler
        // mod_rewrite: handler_redirect (r->filename = "redirect:XXX")
        // mod_cgi: cgi_handler (r->handler == "cgi_handler")
            cgi_handler()
                ap_add_common_vars(); // 填充subprocess_env
                ap_add_cgi_vars();    // 进一步填充subprocess_env
                cgi_build_command();  // default_build_command(), command = r->filename, 计算argc, argv
                run_cgi_child();      // apr_proc_create() fork and pipe
        // mod_php: php_handler
ap_run_log_transaction(); // update child status => SERVER_BUSY_LOG
</code></pre>
<br>
<br>

<p style="color:red">handler是在哪个地方确定下来的?</p>
<pre>
mod_core: SetHandler
    &lt;FilesMatch "\.ph(p3?|tml)$"&gt;
        SetHandler application/x-httpd-php
    &lt;/FilesMatch>
    &lt;FilesMatch "\.phps$"&gt;
        SetHandler application/x-httpd-php-source
    &lt;/FilesMatch&gt;
mod_mime: AddHandler
    // 一个hashtable记录着ext => ext_info(包含handler)
    AddHandler cgi-script .cgi
</pre>

<h3>TOY HTTP SERVER</h3>
<pre><code class="language-c">    socket()
    bind()
    listen()
    while (conn = accept()) {
        fork();
        // child process request
        // parent wait child exit
    }
</code></pre>

<h3>APACHE HTTPD(prefork) 2.2.31</h3>
<pre><code class="language-c">/*
    Listen 80
    &lt;FilesMatch "\.ph(p3?|tml)$"&gt;
        SetHandler application/x-httpd-php
    &lt;/FilesMatch&gt;
    NameVirtualHost *:80
    &lt;VirtualHost *:80&gt;
        DocumentRoot "/path/to/a.example.com"
        ServerName a.example.com
    &lt;/VirtualHost&gt;
    &lt;VirtualHost *:80&gt;
        DocumentRoot "/path/to/b.example.com"
        ServerName b.example.com
    &lt;/VirtualHost&gt;
*/
    socket()
    bind()
    listen()
    // create proc mutex, scoreboard
    // fork children, parent wait child exit, create new child
    // child-1                                                  |  child-2
    while (connection_count &lt; MaxRequestsPerChild) {            |   while (connection_count &lt; MaxRequestsPerChild) {
        mutex_lock()                                            |       mutex_lock()
        conn = accept()                                         |       conn = accept()
        mutex_unlock();                                         |       mutex_unlock();
        create_connection();                                    |       create_connection();
        set conn vhost lookup data(default_list->names)         |       set conn vhost lookup data(default_list->names)
        if lookup failed, base_server = "a.example.com"         |       if lookup failed, base_server = "a.example.com"
        while (keepalive) {                                     |       while (keepalive) {
            read_request();                                     |           read_request();
            process_request();                                  |           process_request();
        }                                                       |       }
        connection_count++;                                     |       connection_count++;
    }                                                           |   }
    child_exit();                                               |   child_exit();

// NameVirtualHost *:80
struct server_addr_rec *name_vhost_list = {
    server_addr_rec *next       = NULL;
    apr_sockaddr_t *host_addr   = apr_sockaddr_info_get(&my_addr, "0.0.0.0", APR_INET, 80);
    apr_port_t host_port        = 80;
    chr *virthost               = "*";
};
// &lt;VirtualHost *:80&gt; ... &lt;/VirtualHost&gt;
server_rec *s = {
    int is_virtual = 1;
    server_addr_rec *addrs = {
        server_addr_rec *next       = NULL;
        apr_sockaddr_t *host_addr   = apr_sockaddr_info_get(&my_addr, "0.0.0.0", APR_INET, 80);
        apr_port_t host_port        = 80;
        chr *virthost               = "*";
    }
    char *server_hostname = "a.example.com"; // ServerName a.example.com
    apr_port_t port = 0;
    struct ap_conf_vector_t *module_config = {
        // ...
        core_module: struct core_server_config = {
            ap_document_root = "/path/to/a.example.com";
        }
        // ...
    };
};

// main_server -> b.example.com -> a.example.com -> NULL

ap_fixup_virtual_hosts(); // merge main server config
ap_fini_vhost_config();
    struct ipaddr_chain *default_list = {
        // build from name_vhost_list
        ipaddr_chain *next   = NULL;
        server_addr_rec *sar = {host_port = 80, virthost = *};
        // build from main server linked list
        server_rec *server   = "a.example.com";
        name_chain *names    = {
            server_addr_rec *sar = {host_port = 80, virthost = *}
            server_rec *server = {a.example.com}
        }  --> {
            server_addr_rec *sar = {host_port = 80, virthost = *}
            server_rec *server = {b.example.com}
        };
    };

// read_request
request_rec {
    // read_request_line
    char *the_request       = "GET /?key=val HTTP/1.1";
    char *method            = "GET";
    int   method_number       = M_GET;
    char *unparsed_uri      = "/?key=val"
    apr_uri_t parsed_uri    = {scheme,hostinfo,user,password,hostname,port_str,path,query,fragment,...};
    char *args              = "key=val";
    char *uri               = "/";
    char *protocol          = "HTTP/1.1";
    int   proto_num           = HTTP_VERSION(1, 1);
    // ap_get_mime_headers_core()
    apr_table_t *headers_in;
    // ap_update_vhost_from_headers()
    char *host = "a.example.com";
    server_rec *server = {a.example.com}; // 默认值: conn->base_server
                                          // conn->base_server在conn创建时=ap_server_conf=main_server (@see prefork_open_logs)
                                          // 在find vhost lookup data时,=default_list->server
                                          // search host in vhost lookup data(default_list->names)
                                          // 所以,一旦配置了虚拟主机,就没有main server
}

// process_request
    ap_run_quick_handler(); // mod_cache
    ap_process_request_internal();
    request_rec {
        // ap_run_translate_name
        char *filename = "/tmp/a.example.com/";
        // ap_run_map_to_storage
        apr_finfo_t finfo = apr_stat(...);
        // ap_run_header_parser
        // module aaa
        // ap_run_type_checker(): 如果配置了mime_module的AddHandler,那么这里就定下来了r->handler
        // ap_run_fixups(): core_override_type() FilesMatch php SetHandler application/x-httpd-php
    }
    ap_invoke_handler();
        // 如果到这里还没有确定handler,那么handler = r->content_type || "text/plain"
        ap_run_handler();
</code></pre>

<h3>mod php</h3>
<pre><code class="language-c">ap_hook_pre_config: php_pre_config: // 如果apache是threaded_mpm,php要threadsafe
ap_hook_post_config: php_apache_server_startup
ap_hook_handler: php_handler
ap_hook_child_init: php_apache_child_init


php_handler(request_rec *r);
    // 检查r->finfo确认php脚本文件是存在的
    ap_add_common_vars(r);
        /*
            CONTENT_TYPE/CONTENT_LENGTH
            HTTP_HEADERS
            PATH
            SERVER_SIGNATURE
            SERVER_SOFTWARE
            SERVER_NAME
            SERVER_ADDR
            SERVER_PORT
            // REMOTE_HOST
            REMOTE_ADDR
            DOCUMENT_ROOT
            SERVER_ADMIN
            SCRIPT_FILENAME
            REMOTE_PORT
            // REMOTE_USER
            // REDIRECT_REMOTE_USER
            // AUTH_TYPE
            // REMOTE_IDENT
            // REDIRECT_QUERY_STRING
            // REDIRECT_URL
        */
    ap_add_cgi_vars(r);
        /*
            GATEWAY_INTERFACE="CGI/1.1"
            SERVER_PROTOCOL=r->protocol
            REQUEST_METHOD=r->method
            QUERY_STRIN=r->args || ""
            REQUEST_URI="/?key=val"
            SCRIPT_NAME
            PATH_INFO
            // PATH_TRANSLATED
        */
    php_apache_request_ctor();
        // build sapi_globals.request_info
        php_execute_script(zend_file_handle zfd);
</code></pre>

<h3>TODO</h3>
input_filters, output_filters<br>
从input_filters里get_brigade,读取输入.<br>
pass_brigade到ourput_filters,输出.<br>
细节是怎么回事还要再细看.


<h3>ab测试</h3>
<pre># 编译httpd
./configure --prefix=/home/heguangyu5/my-httpd/
make
make install

# httpd.conf
Listen 8888

NameVirtualHost *:8888
&lt;VirtualHost *:8888&gt;
	ServerName a.example.com
	DocumentRoot /var/www/a.example.com
	&lt;Directory "/var/www/a.example.com"&gt;
		Order allow,deny
		Allow from all
	&lt;/Directory&gt;
&lt;/VirtualHost&gt;

&lt;VirtualHost *:8888&gt;
	ServerName b.example.com
	DocumentRoot /var/www/b.example.com
	&lt;Directory "/var/www/b.example.com"&gt;
		Order allow,deny
		Allow from all
	&lt;/Directory&gt;
&lt;/VirtualHost&gt;

sudo ./httpd -k start

mpm_prefork_module:
    StartServers 5 # ps aux | grep httpd 可验证, 1个root的process(parent)和5个daemon的process(child)
    MinSpareServers 5
    MaxSpareServers 10
    ServerLimit 256 (最大能调整到20W)
    MaxClients 256 (默认等于ServerLimit)
    MaxRequestsPerChild 10000

httpd默认启动5个child server,每一个tcp connection会占用一个child server,当前最多启动256个child server.
每个server处理过10000个tcp connection后,会exit. 注意是10000个tcp connection,不是http请求.
访问一个页面,浏览器可能会open多个tcp connection,而不是1个.

所以,为了支持N个并发连接,必须有N个child server.
为了支持N个并发用户,必须有 N * 浏览器open的tcp connection数(@see http://www.browserscope.org/?category=network, 大多数是6).
由于大多数浏览器都会keep alive,所以一旦child server accept了conn,这个conn就会占用这个server几秒时间.

其它需要考虑的就是kernel调度这么多child server执行消耗cpu,内存,io的问题了.

httpd支持的并发用户数 = MaxClients / 6 = 256 / 6 = 43
即使httpd处理http请求非常快,由于keepalive的原因,在几秒内child server并不能处理其它请求

验证: 写个php脚本,fork出300个child,每个child发一个http请求并keep alive. 前256个应该很快就返回了,后边的要等上几秒才能拿到结果.

httpd.conf 调整 MaxSpareServers 256
执行几次 php test-keepalive.php 让child server都启动起来
然后再执行一次 php test-keepalive.php, 观察结果: 有256个php client child 5秒结束,其它的10秒结束.


httpd默认KeepAliveTimeout=5,MaxKeepAliveRequests=100.
具体意思是: tcp connection建立后,可以每隔5秒发一个请求,最多发100个.
run test-keepalive-timeout-max.php
</pre>

<code>support/ab.c</code>
<pre><code class="language-c">// ab.c的main()函数处理好命令行参数后,调用test()执行测试
test()
    // 分配concurrency个connection,准备好request
    // for循环start_connect: socket_create,socket_connect,write_request,add socketfd到pollset
    // poll监控服务器端响应,如果连接出错了,重新连;如果服务器正常响应了,read_response.
    // read_response先拿到header,根据header里的Keep-Alive确定服务器端是否支持keepalive,支持的话继续write_request
    // 否则服务器端断开连接,ab会读到EOF,然后就close connection了.

// 结论: 由于ab会尽可能的使用keepalive connection(httpd默认配置的话,一个connection可以完成100个request),
//      所以ab的测试结果更多表明了服务器端处理request的速度(read_request,process_request,invoke_handler),
//      而真实应用场景里(拿chrome举例,chrome发起6个tcp connection,这6个完全断开前,可以发出600个request,这是1个并发用户),会加上很多tcp连接关闭的消耗.

// test default_handler send static file index.html 39980 bytes
// Intel® Core™ i5-3450 CPU @ 3.10GHz × 4
ab -c 100 -n 10000 -k http://a.example.com:8888/index.html
// 服务器有256个server可用,100并发不用等,全都立即accept了,每个connection处理100个request,不需要再发起tcp连接.
// 结果: 10ms
ab -c 256 -n 10000 -k http://a.example.com:8888/index.html
// 服务器有256个server可用,100并发不用等,全都立即accept了,每个connection处理&lt;50个request,不需要再发起tcp连接.
// 结果: 20ms (服务器调度256个server在4个cpu执行导致的?)
ab -c 300 -n 10000 -k http://a.example.com:8888/index.html
// 服务器有256个server可用,300并发,后来的40多个connection要等一下,在listen backlog queue里等着accept.
// 结果: 30ms
ab -c 400 -n 10000 -k http://a.example.com:8888/index.html
// 400并发,listen backlog queue超出了
// 结果: 30ms failed: 117 requests
600并发, connection reset by peer (why? what happens when backlog is full?)
</code></pre>


</div>
<script src="prism.js"></script>
</body>
</html>
