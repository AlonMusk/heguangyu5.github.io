<meta charset="utf-8">
<style type="text/css">
pre {
    max-width: 800px;
    white-space: pre-wrap;
}
</style>

<h3>如何编译内核?</h3>

<pre>
1. 从 https://www.kernel.org/ 下载kernel源码. 如: linux-3.13.tar.xz
2. 解压
3.  cd /path/to/linux-3.13
        make mrproper
        mkdir -p build/kernel
        make O=/path/to/linux-3.13/build/kernel menuconfig
        make O=/path/to/linux-3.13/build/kernel
        sudo make O=/path/to/linux-3.13/build/kernel modules_install install
4. install的结果会在 /boot/ 目录生成4个文件
        config-3.13.0
        initrd.img-3.13.0
        System.map-3.13.0
        vmlinuz-3.13.0
    还会在 /lib/modules 目录生成一个 3.13.0 子目录,里边包含了编译好的modules以及其它一些不知道干嘛的文件
5. /lib/modules里有两个软链接
        build -> /path/to/linux-3.13/build/kernel
        source -> /path/to/linux-3.13
    build这个目录在编译module时会用到.
</pre>

<h3>如何编译自己的module?</h3>
<pre>
1. 直接编译
    make -C /path/to/linux-3.13/build/kernel M=`pwd` modules
2. 懒人做法
    Makefile
        利用 /lib/modules/3.13.0/build 目录
        @see ldd3 page 24
</pre>

<h3>如何加载卸载module</h3>
<pre>
1. tail -f /var/log/syslog
2. sudo insmod ./hello.ko
3. sudo rmmod hello

或者使用modprobe
</pre>

<h3>如何查看kernel当前已经加载的modules?</h3>
<pre>
    cd /sys/module
OR
    cat /proc/modules
</pre>

<h3>kernel当前加载了多少device?</h3>
<pre>
    cat /proc/devices
</pre>

<h3>device如何加载进kernel?</h3>
<pre>
首先要定下来device major number. 有两种办法:
1. 自已定一个,然后MKDEV(major_number, minor_number),再register_chrdev_region(first_dev, count, dev_name)
2. 让kernel动态分配一个(preferred),alloc_chrdev_region(&dev, firstminor, count, dev_name)
    kernel使用一个hashtable chrdevs[CHRDEV_MAJOR_HASH_SIZE=255]来管理所有的char devices.
    动态分配的major number就是chrdevs从后向前第一个null的index.
然后初始化一个struct cdev, add进kernel. 初始化也有两种办法:
1. struct cdev *my_cdev = cdev_alloc(); my_cdev->ops = &my_fops;
2. cdev_init(&my_cdev, &my_fpos);
最后cdev_add(&cdev, MKDEV(major, minor), count = 1).
kernel使用一个struct kobj_map *cdev_map来记录所有cdev.
</pre>

<h3>device怎么起作用的?</h3>
<pre>
首先,需要通过mknod生成一个文件,如:

    mknod my_chrdev1 c 200 0

在生成对应的inode时,发现是char device,于是就:

    inode->i_fop = &def_chr_fops;
    inode->i_rdev = rdev;

def_chr_fops.open = chrdev_open.

    struct cdev *p = inode->i_cdev;
    if (!p) {
        kobj = kobj_lookup(cdev_map, inode->i_rdev);
        inode->i_cdev = p = container_of(kobj, struct cdev, kobj);
    }
    filp->f_op = inode->i_cdev->ops;
    filp->f_op->open(inode, filp);
</pre>

<h3>怎么操作/控制device?</h3>
<pre>
Every peripheral device is controlled by writing and reading its registers.

读写这些registers有两种方式:
1. I/O Ports (inb/outb, inw/outw, inl/outl)
2. I/O Memory (ioremap|_PAGE_BIT_IOMAP ioread8/iowrite8, ioread16/iowrite16, ioread32/iowrite32)

At the hardware level, there is no conceptual difference between memory regions and I/O regions: both of them are accessed by asserting electrical signals on the address bus and control bus (i.e., the read and write signals)* and by reading from or writing to the data bus.

如何区分是读取内存还是读取device?

The processor sets another line on the control bus--An I/O ACCESS line. If this line is set, The I/O Controllers from within the I/O SubSystem watches the Address Bus. If the Address Bus currosponds to a number that is assigned to the device, that device takes the value from the data bus and acts upon it. The Memory Controller ignores any request if this line is set. So, if the port number has not been assigned, absolutley nothing happens. No controller acts on it, and the Memory Controller ignores it.
</pre>

<h3>I/O Port如何确定?</h3>
<pre>
看起来像是约定好的.比如 arch/x86/kernel/setup.c

static struct resource standard_io_resources[] = {
	{ .name = "dma1", .start = 0x00, .end = 0x1f,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "pic1", .start = 0x20, .end = 0x21,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "timer0", .start = 0x40, .end = 0x43,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "timer1", .start = 0x50, .end = 0x53,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "keyboard", .start = 0x60, .end = 0x60,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "keyboard", .start = 0x64, .end = 0x64,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "dma page reg", .start = 0x80, .end = 0x8f,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "pic2", .start = 0xa0, .end = 0xa1,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "dma2", .start = 0xc0, .end = 0xdf,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "fpu", .start = 0xf0, .end = 0xff,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO }
};

void __init reserve_standard_io_resources(void)
{
	int i;

	/* request I/O space for devices used on all i[345]86 PCs */
	for (i = 0; i &lt; ARRAY_SIZE(standard_io_resources); i++)
		request_resource(&ioport_resource, &standard_io_resources[i]);
}

所有的I/O Port都保存在ioport_resource里,cat /proc/ioport读取的就是这个数据结构.
</pre>

<h3>I/O Memory如何确定?</h3>
<pre>
PCI device在其Configuration Registers写好了,直接用就行.
</pre>

<h3>IRQ Number怎么确定?</h3>
<pre>
PCI device在其Configuration Registers写好了,直接用就行.
其它设备如果有默认约定,按约定的来.没有的话,就得猜了.怎么猜?
把当前没有用的IRQ Number挨个注册到自己写的handler上,然后启用设备中断,当收到中断信号时就知道是哪个IRQ Number了.
</pre>

<h3>shared IRQ Number是怎么工作的?</h3>
<pre>
注册的时候一定要加上dev_id.
当中断发生时,kernel会调用所有注册这个irq number的handler.
在各自的handler里,要向自己的设备确认是否有中断,如果有,返回handled,这样kernel就不再调用别的handler了.
否则,返回none,这样kernel就继续调用别的handler.
</pre>

<h3>如果查看系统当前IRQ Number的使用情况?</h3>
<pre>
cat /proc/interrupts
</pre>

<h3>Linux Device Model</h3>
<pre>
struct kobject {
    const char *name;
    struct list_head entry;
    struct kobject *parent;
    struct kset *kset;
    struct kobj_type *ktype;
    struct sysfs_dirent *sd;
    struct kref kref;
    unsigned int state_initialized:1;
    unsigned int state_in_sysfs:1;
    unsigned int state_add_uevent_sent:1;
    unsigned int state_remove_uevent_sent:1;
    unsigned int uevent_suppress:1;
};
struct kobj_type {
    void (*release)(struct kobject *kobj);
    const struct sysfs_ops *sysfs_ops;
    struct attribute **default_attrs;
    // ...
};

/*
a set of kobjects of a specific type, belonging to a specific subsystem

A kset defines a group of kobjects.  They can be individually
different "types" but overall these kobjects all want to be grouped
together and operated on in the same manner.  ksets are used to
define the attribute callbacks and other common events that happen to
a kobject.
*/
struct kset {
    struct list_head list;
    spinlock_t list_lock;
    struct kobject kobj;
    const struct kset_uevent_ops *uevent_ops;
};
struct kset *kset_create_and_add(
    const char *name,
    const struct kset_uevent_ops *uevent_ops,
    struct kobject *parent_kobj
) {
    struct kset *kset = kset_create(name, uevent_ops, parent_kobj);
    kobject_add_internal(&k->kobj);
    kobject_uevent(&k->kobj, KOBJ_ADD);
}
/*
kset.list是归属这个kset的kobjects的起点.

            kset {              kobject {               kobject {
       ---&gt;    list   &lt;--------&gt;  entry   &lt;-------&gt;     entry  &lt; --
       |    }                   }                       }         |
       |                                                          |
       |----------------------------------------------------------|

不管是kobject还是kset,只要设置了name,都会在sysfs下创建一个目录,并将每个attribute创建成文件.
*/

/*
If @parent is set, then the parent of the @kobj will be set to it.
If @parent is NULL, then the parent of the @kobj will be set to the
kobject associted with the kset assigned to this kobject. If no kset
is assigned to the kobject, then the kobject will be located in the
root of the sysfs tree.
*/

int kobject_add(struct kobject *kobj, struct kobject *parent, const char *fmt, ...);
struct kobject *kobject_create_and_add(const char *name, struct kobject *parent);
int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype, struct kobject *parent, const char *fmt, ...);
    if (kobj->parent) {
        parent_sd = kobj->parent->sd;
    } else {
        parent_sd = &sysfs_root;
    }
    create_dir(kobj, parent_sd, ..., kobject_name(kobj), &sd);
    kobj->sd = sd;

// sysfs的每个目录对应一个kobject或一个kset.它们都是怎么来的呢?
void __init mnt_init()
{
    sysfs_init()
    fs_kobj = kobject_create_and_add("fs", NULL);
}
/*
显然,第一个创建的目录是fs,我的电脑上fs下有5个子目录,分别是cgroup,ecryptfs,ext4,fuse,pstore

ext4/
├── features
│   ├── batched_discard
│   ├── lazy_itable_init
│   └── meta_bg_resize
└── sda1
    ├── delayed_allocation_blocks
    ├── err_ratelimit_burst
    ├── err_ratelimit_interval_ms
    ├── ...
    ├── lifetime_write_kbytes
    ├── ...
    ├── session_write_kbytes
*/

// 在 fs/ext4/super.c 里 (ext4 module)
module_init(ext4_init_fs)
static int __init ext4_init_fs(void)
{
    ext4_kset = kset_create_and_add("ext4", NULL, fs_kobj);
}
static int ext4_fill_super(struct super_block *sb, void *data, int silent)
{
    struct ext4_sb_info *sbi = kzalloc();
    sbi->s_kobj.kset = ext4_kset;
    kobject_init_and_add(&sbi->s_kobj, &ext4_ktype, NULL, "%s", sb->s_id);
}
static int __init ext4_init_feat_adverts(void)
{
    struct ext4_features *ef = kzalloc();
    ef->f_kobj.kset = ext4_kset;
    kobject_init_and_add(&ef->f_kobj, &ext4_feat_ktype, NULL, "features");
    ext4_feat = ef;
}

struct ext4_sb_info {
    // ...
    struct kboject s_kobj;
    // ...
}
struct ext4_features {
    struct kboject f_kobj;
    // ...
}


static struct kobj_type ext4_ktype = {
    .default_attrs = ext4_attrs,
    .sysfs_ops = &ext4_attr_ops,
    .release = &ext4_sb_release
};
static struct kobj_type ext4_feat_ktype = {
    .default_attrs = ext4_feat_attrs,
    .sysfs_ops = &ext4_attr_ops,
    .release = ext4_feat_release
};

static struct attribute *ext4_attrs[] = {
    &ext4_attr_delayed_allocation_blocks.attr,
    &ext4_attr_session_write_kbytes.attr,
    &ext4_attr_lifetime_write_kbytes.attr,
    // ...
    NULL
};
static struct ext4_feat_attrs[] = {
    &ext4_attr_lazy_itable_init.attr = {.name = lazy_itable_init, .mode = 0444},
    &ext4_attr_batched_discard.attr  = {.name = batched_discard, .mode = 0444},
    NULL
};

// 在 fs/fuse/inode.c 里
module_init(fuse_init);
fuse_init()
{
    fuse_fs_init()
    {
        fuse_kobj = kobject_create_and_add("fuse", fs_kobj);
        connections_kobj = kobject_create_and_add("connections", fuse_kobj);
    }
}
</pre>
