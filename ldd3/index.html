<meta charset="utf-8">
<style type="text/css">
pre {
    max-width: 800px;
    white-space: pre-wrap;
}
</style>

<h3>如何编译内核?</h3>

<pre>
1. 从 https://www.kernel.org/ 下载kernel源码. 如: linux-3.13.tar.xz
2. 解压
3.  cd /path/to/linux-3.13
        make mrproper
        mkdir -p build/kernel
        make O=/path/to/linux-3.13/build/kernel menuconfig
        make O=/path/to/linux-3.13/build/kernel
        sudo make O=/path/to/linux-3.13/build/kernel modules_install install
4. install的结果会在 /boot/ 目录生成4个文件
        config-3.13.0
        initrd.img-3.13.0
        System.map-3.13.0
        vmlinuz-3.13.0
    还会在 /lib/modules 目录生成一个 3.13.0 子目录,里边包含了编译好的modules以及其它一些不知道干嘛的文件
5. /lib/modules里有两个软链接
        build -> /path/to/linux-3.13/build/kernel
        source -> /path/to/linux-3.13
    build这个目录在编译module时会用到.
</pre>

<h3>如何编译自己的module?</h3>
<pre>
1. 直接编译
    make -C /path/to/linux-3.13/build/kernel M=`pwd` modules
2. 懒人做法
    Makefile
        利用 /lib/modules/3.13.0/build 目录
        @see ldd3 page 24
</pre>

<h3>如何加载卸载module</h3>
<pre>
1. tail -f /var/log/syslog
2. sudo insmod ./hello.ko
3. sudo rmmod hello

或者使用modprobe
</pre>

<h3>如何查看kernel当前已经加载的modules?</h3>
<pre>
    cd /sys/module
OR
    cat /proc/modules
</pre>

<h3>kernel当前加载了多少device?</h3>
<pre>
    cat /proc/devices
</pre>

<h3>device如何加载进kernel?</h3>
<pre>
首先要定下来device major number. 有两种办法:
1. 自已定一个,然后MKDEV(major_number, minor_number),再register_chrdev_region(first_dev, count, dev_name)
2. 让kernel动态分配一个(preferred),alloc_chrdev_region(&dev, firstminor, count, dev_name)
    kernel使用一个hashtable chrdevs[CHRDEV_MAJOR_HASH_SIZE=255]来管理所有的char devices.
    动态分配的major number就是chrdevs从后向前第一个null的index.
然后初始化一个struct cdev, add进kernel. 初始化也有两种办法:
1. struct cdev *my_cdev = cdev_alloc(); my_cdev->ops = &my_fops;
2. cdev_init(&my_cdev, &my_fpos);
最后cdev_add(&cdev, MKDEV(major, minor), count = 1).
kernel使用一个struct kobj_map *cdev_map来记录所有cdev.
</pre>

<h3>device怎么起作用的?</h3>
<pre>
首先,需要通过mknod生成一个文件,如:

    mknod my_chrdev1 c 200 0

在生成对应的inode时,发现是char device,于是就:

    inode->i_fop = &def_chr_fops;
    inode->i_rdev = rdev;

def_chr_fops.open = chrdev_open.

    struct cdev *p = inode->i_cdev;
    if (!p) {
        kobj = kobj_lookup(cdev_map, inode->i_rdev);
        inode->i_cdev = p = container_of(kobj, struct cdev, kobj);
    }
    filp->f_op = inode->i_cdev->ops;
    filp->f_op->open(inode, filp);
</pre>

<h3>怎么操作/控制device?</h3>
<pre>
Every peripheral device is controlled by writing and reading its registers.

读写这些registers有两种方式:
1. I/O Ports (inb/outb, inw/outw, inl/outl)
2. I/O Memory (ioremap|_PAGE_BIT_IOMAP ioread8/iowrite8, ioread16/iowrite16, ioread32/iowrite32)

At the hardware level, there is no conceptual difference between memory regions and I/O regions: both of them are accessed by asserting electrical signals on the address bus and control bus (i.e., the read and write signals)* and by reading from or writing to the data bus.

如何区分是读取内存还是读取device?

The processor sets another line on the control bus--An I/O ACCESS line. If this line is set, The I/O Controllers from within the I/O SubSystem watches the Address Bus. If the Address Bus currosponds to a number that is assigned to the device, that device takes the value from the data bus and acts upon it. The Memory Controller ignores any request if this line is set. So, if the port number has not been assigned, absolutley nothing happens. No controller acts on it, and the Memory Controller ignores it.
</pre>

<h3>I/O Port如何确定?</h3>
<pre>
看起来像是约定好的.比如 arch/x86/kernel/setup.c

static struct resource standard_io_resources[] = {
	{ .name = "dma1", .start = 0x00, .end = 0x1f,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "pic1", .start = 0x20, .end = 0x21,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "timer0", .start = 0x40, .end = 0x43,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "timer1", .start = 0x50, .end = 0x53,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "keyboard", .start = 0x60, .end = 0x60,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "keyboard", .start = 0x64, .end = 0x64,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "dma page reg", .start = 0x80, .end = 0x8f,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "pic2", .start = 0xa0, .end = 0xa1,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "dma2", .start = 0xc0, .end = 0xdf,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
	{ .name = "fpu", .start = 0xf0, .end = 0xff,
		.flags = IORESOURCE_BUSY | IORESOURCE_IO }
};

void __init reserve_standard_io_resources(void)
{
	int i;

	/* request I/O space for devices used on all i[345]86 PCs */
	for (i = 0; i &lt; ARRAY_SIZE(standard_io_resources); i++)
		request_resource(&ioport_resource, &standard_io_resources[i]);
}

所有的I/O Port都保存在ioport_resource里,cat /proc/ioport读取的就是这个数据结构.
</pre>

<h3>I/O Memory如何确定?</h3>
<pre>
PCI device在其Configuration Registers写好了,直接用就行.
</pre>

<h3>IRQ Number怎么确定?</h3>
<pre>
PCI device在其Configuration Registers写好了,直接用就行.
其它设备如果有默认约定,按约定的来.没有的话,就得猜了.怎么猜?
把当前没有用的IRQ Number挨个注册到自己写的handler上,然后启用设备中断,当收到中断信号时就知道是哪个IRQ Number了.
</pre>

<h3>shared IRQ Number是怎么工作的?</h3>
<pre>
注册的时候一定要加上dev_id.
当中断发生时,kernel会调用所有注册这个irq number的handler.
在各自的handler里,要向自己的设备确认是否有中断,如果有,返回handled,这样kernel就不再调用别的handler了.
否则,返回none,这样kernel就继续调用别的handler.
</pre>

<h3>如果查看系统当前IRQ Number的使用情况?</h3>
<pre>
cat /proc/interrupts
</pre>
